<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程鹏</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-07T13:33:48.629Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>程鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastDFS单机版安装</title>
    <link href="http://yoursite.com/2019/01/07/FastDFS%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/07/FastDFS单机版安装/</id>
    <published>2019-01-07T13:28:20.920Z</published>
    <updated>2019-01-07T13:33:48.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置镜像加速器-修改daemon配置文件-etc-docker-daemon-json"><a href="#配置镜像加速器-修改daemon配置文件-etc-docker-daemon-json" class="headerlink" title="配置镜像加速器:修改daemon配置文件/etc/docker/daemon.json"></a>配置镜像加速器:修改daemon配置文件<code>/etc/docker/daemon.json</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><a id="more"></a><p>在key为<code>registry-mirrors</code>追加<code>&quot;https://1031vuk0.mirror.aliyuncs.com&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 若没有直接cv大法</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1031vuk0.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启docker刷新配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写<code>docker-compose.yml</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.1&apos;</span><br><span class="line">services:</span><br><span class="line">  fastdfs:</span><br><span class="line">    image: registry.cn-shenzhen.aliyuncs.com/dev_docker_resp/fastdfs</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: fastdfs</span><br><span class="line">    volumes:</span><br><span class="line">      - ./storage:/fastdfs/storage</span><br><span class="line">    network_mode: host</span><br></pre></td></tr></table></figure><ol start="3"><li>运行<code>docker-compose up -d</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置镜像加速器-修改daemon配置文件-etc-docker-daemon-json&quot;&gt;&lt;a href=&quot;#配置镜像加速器-修改daemon配置文件-etc-docker-daemon-json&quot; class=&quot;headerlink&quot; title=&quot;配置镜像加速器:修改daemon配置文件/etc/docker/daemon.json&quot;&gt;&lt;/a&gt;配置镜像加速器:修改daemon配置文件&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir -p /etc/docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo vi /etc/docker/daemon.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker-compose" scheme="http://yoursite.com/categories/docker-compose/"/>
    
    
      <category term="FastDFS" scheme="http://yoursite.com/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件RabbitMQ</title>
    <link href="http://yoursite.com/2019/01/07/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/"/>
    <id>http://yoursite.com/2019/01/07/消息中间件RabbitMQ/</id>
    <published>2019-01-07T13:26:20.060Z</published>
    <updated>2019-01-07T13:29:50.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件RabbitMQ"><a href="#消息中间件RabbitMQ" class="headerlink" title="消息中间件RabbitMQ"></a>消息中间件RabbitMQ</h1><ol><li><h3 id="消息队列中间件简介"><a href="#消息队列中间件简介" class="headerlink" title="消息队列中间件简介"></a>消息队列中间件简介</h3><ul><li>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量<br>削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有<code>ActiveMQ</code>，<code>RabbitMQ</code>，<code>ZeroMQ</code>，<code>Kafka</code>，<code>MetaMQ</code>，<code>RocketMQ</code></li><li>以下介绍消息队列在实际应用中常用的使用场景：<code>异步处理</code>，<code>应用解耦</code>，<code>流量削锋</code>和<code>消息通讯</code>四个场景 </li></ul><a id="more"></a></li><li><h3 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h3><ul><li><code>RabbitMQ</code> 是一个由 <code>Erlang</code>语言开发的<code>AMQP</code>的开源实现。 </li><li><code>AMQP</code>：Advanced Message Queue，高级消息队列协议。它是<code>应用层</code>协议的一个开放标准，为<code>面向消息</code>的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 </li></ul></li><li><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ul><li><strong>RabbitMQ Server</strong>： 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</li><li><strong>Producer</strong>： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服<br>务器然后将消息投递到Exchange。</li><li><strong>Consumer</strong>：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，<br>RabbitMQ将Queue中的消息发送到消息消费者。</li><li><strong>Exchange</strong>：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</li><li><strong>Queue</strong>：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</li><li><strong>RoutingKey</strong>：生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255bytes。</li><li><strong>Connection</strong>： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</li><li><strong>Channels</strong>： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</li><li><strong>VirtualHost</strong>：权限控制的基本单位，一个VirtualHost里面有若干Exchange和<br>MessageQueue，以及指定被哪些user使用 </li></ul></li><li><h3 id="RabbitMQ安装与启动"><a href="#RabbitMQ安装与启动" class="headerlink" title="RabbitMQ安装与启动"></a>RabbitMQ安装与启动</h3><ul><li><p>编写<code>docker-compose.yml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: '3.1'</span><br><span class="line">services:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    restart: always</span><br><span class="line">    image: rabbitmq:management</span><br><span class="line">    container_name: rabbitmq</span><br><span class="line">    ports:</span><br><span class="line">      - 5672:5672</span><br><span class="line">      - 15672:15672</span><br><span class="line">      - 5671:5617</span><br><span class="line">      - 15671:15671</span><br><span class="line">      - 25672:25672</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      RABBITMQ_DEFAULT_USER: rabbit</span><br><span class="line">      RABBITMQ_DEFAULT_PASS: 123456</span><br><span class="line">    volumes:</span><br><span class="line">      - data:/var/lib/rabbitmq</span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br></pre></td></tr></table></figure><p>rabbitmq需要有映射以下端口: 5671、5672、4369、15671、15672、25672</p><ul><li>15672 (if management plugin is enabled)</li><li>15671 management监听端口</li><li>5672, 5671 (AMQP 0-9-1 without and with TLS)</li><li>4369 (epmd) epmd 代表 Erlang 端口映射守护进程</li><li>25672 (Erlang distribution) </li></ul></li><li><p>启动容器<code>docker-compose up -d</code></p></li><li><p>访问地址：<a href="http://IP:15672,即可看到管理界面的登陆页" target="_blank" rel="noopener">http://IP:15672,即可看到管理界面的登陆页</a> </p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;消息中间件RabbitMQ&quot;&gt;&lt;a href=&quot;#消息中间件RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;消息中间件RabbitMQ&quot;&gt;&lt;/a&gt;消息中间件RabbitMQ&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;消息队列中间件简介&quot;&gt;&lt;a href=&quot;#消息队列中间件简介&quot; class=&quot;headerlink&quot; title=&quot;消息队列中间件简介&quot;&gt;&lt;/a&gt;消息队列中间件简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量&lt;br&gt;削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构] 使用较多的消息队列有&lt;code&gt;ActiveMQ&lt;/code&gt;，&lt;code&gt;RabbitMQ&lt;/code&gt;，&lt;code&gt;ZeroMQ&lt;/code&gt;，&lt;code&gt;Kafka&lt;/code&gt;，&lt;code&gt;MetaMQ&lt;/code&gt;，&lt;code&gt;RocketMQ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下介绍消息队列在实际应用中常用的使用场景：&lt;code&gt;异步处理&lt;/code&gt;，&lt;code&gt;应用解耦&lt;/code&gt;，&lt;code&gt;流量削锋&lt;/code&gt;和&lt;code&gt;消息通讯&lt;/code&gt;四个场景 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker-compose" scheme="http://yoursite.com/categories/docker-compose/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/docker-compose/RabbitMQ/"/>
    
    
      <category term="docker-compose" scheme="http://yoursite.com/tags/docker-compose/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
