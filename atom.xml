<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程鹏 | 个人博客</title>
  
  <subtitle>知识是进步的基石，学习是成功的阶梯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-12T01:42:40.709Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>程鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>远程连接Oracle数据库(本地不安装Oracle)</title>
    <link href="http://yoursite.com/2019/07/12/devNote/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/07/12/devNote/远程连接Oracle数据库/</id>
    <published>2019-07-12T00:49:05.311Z</published>
    <updated>2019-07-12T01:42:40.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载Oracle客户端"><a href="#下载Oracle客户端" class="headerlink" title="下载Oracle客户端"></a>下载Oracle客户端</h3><p><code>instantclient-basic-windows.x64-11.2.0.4.0</code>网盘链接：<a href="https://pan.baidu.com/s/1cmLH2EWHqZ-VI0QBCDy0kQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cmLH2EWHqZ-VI0QBCDy0kQ</a><br>提取码：<code>zlxu</code></p><h3 id="配置Oracle客户端"><a href="#配置Oracle客户端" class="headerlink" title="配置Oracle客户端"></a>配置Oracle客户端</h3><ol><li><p>将客户端压缩包解压</p></li><li><p>进入解压目录，新建文件夹<code>NETWORK</code>并进入其再新建文件夹<code>ADMIN</code></p></li><li><p>进入文件夹<code>ADMIN</code>，创建<code>tnsnames.ora</code>文件并编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ORCL = </span><br><span class="line">   (DESCRIPTION = </span><br><span class="line">     (ADDRESS_LIST = </span><br><span class="line">       (ADDRESS = (PROTOCOL = TCP)(HOST = YOURSERVERIP )(PORT = 1521)) </span><br><span class="line">     ) </span><br><span class="line">     (CONNECT_DATA = </span><br><span class="line">   (SERVICE = DEDICATED)</span><br><span class="line">       (SERVICE_NAME = YOURDBNAME) </span><br><span class="line">     ) </span><br><span class="line">   )</span><br></pre></td></tr></table></figure><ul><li><code>ORCL</code>：本机识别服务名，可任意命名，不重复即可</li><li><code>YOURSERVERIP</code>：待连接Oracle数据库服务器IP地址</li><li><code>1521</code>：Oracle数据库暴露的端口号，默认则无需修改</li><li><code>YOURDBNAME</code>：远程数据库服务名，需要按照数据库的服务器进行设置，如远程数据库名为<code>test_db</code>，则设置为<code>test_db</code>。</li></ul></li></ol><h3 id="环境变量准备"><a href="#环境变量准备" class="headerlink" title="环境变量准备"></a>环境变量准备</h3><ul><li><p>新建变量<code>NLS_LANG</code>，值为<code>AMERICAN_AMERICA.AL32UTF8</code></p></li><li><p>新建变量<code>TNS_ADMIN</code>，值为<code>${ClientPath}\NETWORK\ADMIN</code>，比如我的设置为<code>D:\Software\DevSoftware\instantclient_12_1\NETWORK\ADMIN</code>。</p></li></ul><h3 id="配置图形化界面软件"><a href="#配置图形化界面软件" class="headerlink" title="配置图形化界面软件"></a>配置图形化界面软件</h3><h4 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h4><ol><li><p>点击<code>工具</code>-&gt;<code>选项</code>-&gt;<code>环境</code></p></li><li><p>修改<code>OCI环境</code>，将<code>OCI library(oci.dll)*</code>的值设置为Oracle客户端解压文件中的<code>oci.dll</code></p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/远程连接Oracle数据库/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/1.png"></p></li><li><p>重启Navicat，再次连接远端Oracle数据库即可成功</p></li><li><p>连接数据库配置，选择<code>TNS</code>方式连接</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/远程连接Oracle数据库/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/2.png"></p></li></ol><h4 id="PL-SQL-Developer"><a href="#PL-SQL-Developer" class="headerlink" title="PL/SQL Developer"></a>PL/SQL Developer</h4><ol><li><p>进入<code>PL/SQL</code>，不填数据库选项，选择<code>Cancle</code>即可进入<code>PL/SQL</code></p></li><li><p>点击<code>Tools</code>-&gt;<code>Preferences</code>j进行配置客户端信息</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/远程连接Oracle数据库/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/3.png"></p></li><li><p>重启输入Oracle信息即可成功连接</p><ul><li><code>Username</code>：为远程数据库用户名</li><li><code>Password</code>：远程数据库密码</li><li><code>Database</code>：与<code>tnsnames.ora</code>与本机识别服务名相同</li><li><code>Connect as</code>：根据用户再数据库中的角色选择即可</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载Oracle客户端&quot;&gt;&lt;a href=&quot;#下载Oracle客户端&quot; class=&quot;headerlink&quot; title=&quot;下载Oracle客户端&quot;&gt;&lt;/a&gt;下载Oracle客户端&lt;/h3&gt;&lt;p&gt;&lt;code&gt;instantclient-basic-windows.
      
    
    </summary>
    
      <category term="JavaUtils" scheme="http://yoursite.com/categories/JavaUtils/"/>
    
    
      <category term="JavaUtils" scheme="http://yoursite.com/tags/JavaUtils/"/>
    
  </entry>
  
  <entry>
    <title>Java HotSpot VM选项</title>
    <link href="http://yoursite.com/2019/07/11/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Java%20HotSpot%20VM%E9%80%89%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/07/11/性能优化/Java HotSpot VM选项/</id>
    <published>2019-07-11T06:21:36.504Z</published>
    <updated>2019-07-11T06:24:07.013Z</updated>
    
    <content type="html"><![CDATA[<p>Java HotSpot VM选项以下选项分为不同类别。</p><ul><li><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#BehavioralOptions" target="_blank" rel="noopener">行为选项会</a>更改VM的基本行为。</li><li><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#G1Options" target="_blank" rel="noopener">垃圾优先（G1）垃圾收集选项</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#PerformanceTuning" target="_blank" rel="noopener">性能调整</a>选项是旋钮，可用于调整VM性能。</li><li><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#DebuggingOptions" target="_blank" rel="noopener">调试选项</a>通常可以跟踪，打印或输出VM信息。</li></ul><p><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="G1-垃圾收集选项参数"><a href="#G1-垃圾收集选项参数" class="headerlink" title="G1 垃圾收集选项参数"></a>G1 垃圾收集选项参数</h3><a id="more"></a><table><thead><tr><th>选项及默认值</th><th>说明</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>使用垃圾优先（G1）收集器</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>设置最大GC暂停时间的目标。这是一个软目标，JVM将尽最大努力实现它。</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=n</td><td>启动并发GC循环的（整个）堆占用百分比。它由GC使用，它基于整个堆的占用而不仅仅是其中一代（例如，G1）触发并发GC循环。值0表示“执行恒定GC循环”。默认值为45。</td></tr><tr><td>-XX:NewRatio=n</td><td>旧/新一代尺寸的比例。默认值为2。</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>eden/survivor区空间大小的比率。默认值为8。</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>终身临界值的最大值。默认值为15。</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置垃圾收集器并行阶段使用的线程数。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发垃圾收集器将使用的线程数。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:G1ReservePercent=n</td><td>设置保留为false上限的堆的数量，以减少促销失败的可能性。默认值为10。</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td>使用G1，Java堆被细分为大小均匀的区域。这设置了各个子部门的大小。根据堆大小，符合人体工程学地确定此参数的默认值。最小值为1Mb，最大值为32Mb。</td></tr></tbody></table><h3 id="行为选项及默认值选项参数"><a href="#行为选项及默认值选项参数" class="headerlink" title="行为选项及默认值选项参数"></a>行为选项及默认值选项参数</h3><table><thead><tr><th>选项及默认值</th><th>说明</th></tr></thead><tbody><tr><td>-XX:-AllowUserSignalHandlers</td><td>如果应用程序安装了信号处理程序，请不要抱怨。（仅与Solaris和Linux相关。）</td></tr><tr><td>-XX:AltStackSize=16384</td><td>备用信号堆栈大小（以千字节为单位）。（仅与Solaris相关，从5.0中删除。）</td></tr><tr><td>-XX:-DisableExplicitGC</td><td>默认情况下，启用对System.gc（）的调用（-XX：-DisableExplicitGC）。使用-XX：+ DisableExplicitGC禁用对System.gc（）的调用。请注意，JVM在必要时仍会执行垃圾回收。</td></tr><tr><td>-XX:+FailOverToOldVerifier</td><td>新类型检查程序失败时故障转移到旧验证程序。（在6中引入）</td></tr><tr><td>-XX:+HandlePromotionFailure</td><td>最年轻的一代系列不需要保证所有活动对象的完全升级。（在1.4.2更新11中引入）[5.0及更早版本：false。]</td></tr><tr><td>-XX:+MaxFDLimit</td><td>将文件描述符的数量转换为最大值。（仅与Solaris相关。）</td></tr><tr><td>-XX:PreBlockSpin=10</td><td>用于-XX的旋转计数变量：+ UseSpinning。控制在输入操作系统线程同步代码之前允许的最大旋转迭代。（在1.4.2中引入。）</td></tr><tr><td>-XX:-RelaxAccessControlCheck</td><td>放宽验证程序中的访问控制检查。（在6中引入）</td></tr><tr><td>-XX:+ScavengeBeforeFullGC</td><td>在完整GC之前进行年轻一代GC。（在1.4.1中介绍。）</td></tr><tr><td>-XX:+UseAltSigs</td><td>对于VM内部信号，使用备用信号而不是SIGUSR1和SIGUSR2。（在1.3.1更新9中引入，1.4.1。仅与Solaris相关。）</td></tr><tr><td>-XX:+UseBoundThreads</td><td>将用户级线程绑定到内核线程。（仅与Solaris相关。）</td></tr><tr><td>-XX:-UseConcMarkSweepGC</td><td>为旧一代使用并发标记扫描集合。（在1.4.1中引入）</td></tr><tr><td>-XX:+UseGCOverheadLimit</td><td>使用策略限制在引发OutOfMemory错误之前在GC中花费的VM时间的比例。（在6中引入）</td></tr><tr><td>-XX:+UseLWPSynchronization</td><td>使用基于LWP而不是基于线程的同步。（在1.4.0中引入。仅与Solaris相关。）</td></tr><tr><td>-XX:-UseParallelGC</td><td>使用并行垃圾收集清除。（在1.4.1中引入）</td></tr><tr><td>-XX:-UseParallelOldGC</td><td>对完整集合使用并行垃圾回收。启用此选项会自动设置-XX：+ UseParallelGC。（在5.0更新中引入6.）</td></tr><tr><td>-XX:-UseSerialGC</td><td>使用串行垃圾收集。（5.0中引入。）</td></tr><tr><td>-XX:-UseSpinning</td><td>在进入操作系统线程同步代码之前，在Java监视器上启用朴素旋转。（仅与1.4.2和5.0相关。）[1.4.2，多处理器Windows平台：true]</td></tr><tr><td>-XX:+UseTLAB</td><td>使用线程局部对象分配（在1.4.0中引入，在此之前称为UseTLE。）[1.4.2和更早版本，x86或使用-client：false]</td></tr><tr><td>-XX:+UseSplitVerifier</td><td>使用具有StackMapTable属性的新类型检查器。（在5.0中引入。）[5.0：false]</td></tr><tr><td>-XX:+UseThreadPriorities</td><td>使用本机线程优先级。</td></tr><tr><td>-XX:+UseVMInterruptibleIO</td><td>在EINTR之前或与EINTR进行I / O操作的线程中断导致OS_INTRPT。（仅在Solaris中引入。仅与Solaris相关。）</td></tr></tbody></table><h3 id="性能选项参数"><a href="#性能选项参数" class="headerlink" title="性能选项参数"></a>性能选项参数</h3><table><thead><tr><th>选项及默认值</th><th>说明</th></tr></thead><tbody><tr><td>-XX:+AggressiveOpts</td><td>打开预期在即将发布的版本中默认的点性能编译器优化。（在5.0更新中引入6.）</td></tr><tr><td>-XX:CompileThreshold=10000</td><td>编译前的方法调用/分支数[-client：1,500]</td></tr><tr><td>-XX:LargePageSizeInBytes=4m</td><td>设置用于Java堆的大页面大小。（在1.4.0更新1中引入。）[amd64：2m。]</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>GC后最大堆积空闲百分比以避免收缩。</td></tr><tr><td>-XX:MaxNewSize=size</td><td>新一代的最大大小（以字节为单位）。从1.4开始，MaxNewSize被计算为NewRatio的函数。[1.3.1 Sparc：32m; 1.3.1 x86：2.5米。]</td></tr><tr><td>-XX:MaxPermSize=64m</td><td>永久代的大小。[5.0及更新版本：64位虚拟机缩放30％; 1.4 amd64：96m; 1.3.1 -client：32m。]</td></tr><tr><td>-XX:MinHeapFreeRatio=40</td><td>GC后最小的堆积百分比以避免扩展。</td></tr><tr><td>-XX:NewRatio=2</td><td>旧/新一代尺寸的比例。[Sparc -client：8; x86 -server：8; x86 -client：12。] - 客户端：4（1.3）8（1.3.1 +），x86：12]</td></tr><tr><td>-XX:NewSize=2m</td><td>新一代的默认大小（以字节为单位）[5.0及更新版本：64位虚拟机缩放30％; x86：1米; x86,5.0及更早版本：640k]</td></tr><tr><td>-XX:ReservedCodeCacheSize=32m</td><td>保留代码缓存大小（以字节为单位） - 最大代码缓存大小。[Solaris 64位，amd64和-server x86：2048m; 在1.5.0_06及更早版本中，Solaris 64位和amd64：1024m。</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>eden/survivor区空间大小的比例[Solaris amd64：6; Sparc在1.3.1：25; 5.0及更早版本中的其他Solaris平台：32]</td></tr><tr><td>-XX:TargetSurvivorRatio=50</td><td>清除后使用的幸存者空间的所需百分比。</td></tr><tr><td>-XX:ThreadStackSize=512</td><td>线程堆栈大小（以KB为单位）。（0表示使用默认堆栈大小）[Sparc：512; Solaris x86：320（在5.0及更早版本中为256之前的版本）; Sparc 64位：1024; Linux amd64：1024（5.0及更早版本中为0）; 所有其他的0.]</td></tr><tr><td>-XX:+UseBiasedLocking</td><td>启用偏置锁定。有关更多详细信息，请参阅此<a href="https://www.oracle.com/technetwork/java/tuning-139912.html#section4.2.5" target="_blank" rel="noopener">调整示例</a>。（在5.0更新中引入6.）[5.0：false]</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>使用优化版本的Get <primitive> Field。</primitive></td></tr><tr><td>-XX:-UseISM</td><td>使用亲密共享内存。[不适用于非Solaris平台。]有关详细信息，请参阅<a href="https://www.oracle.com/technetwork/java/ism-139376.html" target="_blank" rel="noopener">私密共享内存</a>。</td></tr><tr><td>-XX:+UseLargePages</td><td>使用大页面内存。（在5.0更新5中引入。）有关详细信息，请参阅<a href="https://www.oracle.com/technetwork/java/javase/tech/largememory-jsp-137182.html" target="_blank" rel="noopener">Java支持大内存页面</a>。</td></tr><tr><td>-XX:+UseMPSS</td><td>使用具有4mb页面的多页面大小支持。不要与ISM一起使用，因为这取代了对ISM的需求。（在1.4.0更新1中引入，与Solaris 9及更新版本相关。）[1.4.1及更早版本：false]</td></tr><tr><td>-XX:+UseStringCache</td><td>启用常用分配字符串的缓存。</td></tr><tr><td>-XX:AllocatePrefetchLines=1</td><td>使用JIT编译代码中生成的预取指令在最后一次对象分配后加载的高速缓存行数。如果最后分配的对象是实例，则默认值为1;如果是数组，则默认值为3。</td></tr><tr><td>-XX:AllocatePrefetchStyle=1</td><td>生成预取指令的代码样式。<br>0 - 没有生成预取指令<em> d </em>，<br>1 - 在每次分配后执行预取指令，<br>2 - 在执行预取指令时使用TLAB分配水印指针到门。</td></tr><tr><td>-XX:+UseCompressedStrings</td><td>对字符串使用byte []，可以表示为纯ASCII。（在Java 6 Update 21性能发布中引入）</td></tr><tr><td>-XX:+OptimizeStringConcat</td><td>尽可能优化字符串连接操作。（在Java 6 Update 20中引入）</td></tr></tbody></table><h3 id="调试选项及默认值参数"><a href="#调试选项及默认值参数" class="headerlink" title="调试选项及默认值参数"></a>调试选项及默认值参数</h3><table><thead><tr><th>选项及默认值</th><th>说明</th></tr></thead><tbody><tr><td>-XX:-CITime</td><td>打印在JIT编译器中花费的时间。（在1.4.0中引入。）</td></tr><tr><td>-XX:ErrorFile=./hs_err_pid<pid>.log</pid></td><td>如果发生错误，请将错误数据保存到此文件中。（在6中引入）</td></tr><tr><td>-XX:-ExtendedDTraceProbes</td><td>启用影响性能的<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/dtrace.html" target="_blank" rel="noopener">dtrace</a>探针。（仅在Solaris中引入。仅与Solaris相关。）</td></tr><tr><td>-XX:HeapDumpPath=./java_pid<pid>.hprof</pid></td><td>堆转储的目录或文件名的路径。<em>可管理</em>。（在1.4.2更新12,5.0更新7中引入。）</td></tr><tr><td>-XX:-HeapDumpOnOutOfMemoryError</td><td>抛出java.lang.OutOfMemoryError时转储堆到文件。<em>可管理</em>。（在1.4.2更新12,5.0更新7中引入。）</td></tr><tr><td>-XX:OnError=”<cmd args="">;<cmd args="">“</cmd></cmd></td><td>在致命错误上运行用户定义的命令。（在1.4.2更新9中引入）</td></tr><tr><td>-XX:OnOutOfMemoryError=”<cmd args="">;<br><cmd args="">“</cmd></cmd></td><td>首次抛出OutOfMemoryError时运行用户定义的命令。（在1.4.2更新12,6中引入）</td></tr><tr><td>-XX:-PrintClassHistogram</td><td>在Ctrl-Break上打印类实例的直方图。<em>可管理</em>。（在1.4.2中引入。）<a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jmap.html" target="_blank" rel="noopener">jmap -histo</a>命令提供了等效的功能。</td></tr><tr><td>-XX:-PrintConcurrentLocks</td><td>在Ctrl-Break线程转储中打印java.util.concurrent锁。<em>可管理</em>。（在6.中引入）<a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstack.html" target="_blank" rel="noopener">jstack -l</a>命令提供等效功能。</td></tr><tr><td>-XX:-PrintCommandLineFlags</td><td>打印出现在命令行上的标志。（5.0中引入。）</td></tr><tr><td>-XX:-PrintCompilation</td><td>编译方法时打印消息。</td></tr><tr><td>-XX:-PrintGC</td><td>在垃圾收集中打印消息。<em>可管理</em>。</td></tr><tr><td>-XX:-PrintGCDetails</td><td>在垃圾收集中打印更多细节。<em>可管理</em>。（在1.4.0中引入。）</td></tr><tr><td>-XX:-PrintGCTimeStamps</td><td>打印垃圾回收时的时间戳。<em>可管理</em>（1.4.0中引入）</td></tr><tr><td>-XX:-PrintTenuringDistribution</td><td>打印终身年龄信息。</td></tr><tr><td>-XX:-PrintAdaptiveSizePolicy</td><td>允许打印有关自适应生成大小的信息。</td></tr><tr><td>-XX:-TraceClassLoading</td><td>跟踪类的加载。</td></tr><tr><td>-XX:-TraceClassLoadingPreorder</td><td>跟踪按引用顺序（未加载）加载的所有类。（在1.4.2中引入。）</td></tr><tr><td>-XX:-TraceClassResolution</td><td>跟踪按引用顺序（未加载）加载的所有类。（在1.4.2中引入。）</td></tr><tr><td>-XX:-TraceClassUnloading</td><td>跟踪卸载类。</td></tr><tr><td>-XX:-TraceLoaderConstraints</td><td>跟踪记录装载机约束。（在6中引入）</td></tr><tr><td>-XX:+PerfDataSaveToFile</td><td>退出时保存jvmstat二进制数据。</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置年轻和旧的并行垃圾收集器中的垃圾收集线程数。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:+UseCompressedOops</td><td>允许使用压缩指针（对象引用表示为32位偏移而不是64位指针），以优化64位性能，Java堆大小小于32gb。</td></tr><tr><td>-XX:+AlwaysPreTouch</td><td>在JVM初始化期间预先触摸Java堆。因此，堆的每个页面在初始化期间都是需求归零，而不是在应用程序执行期间递增。</td></tr><tr><td>-XX:AllocatePrefetchDistance=n</td><td>设置对象分配的预取距离。将使用新对象的值写入的内存以超出最后分配的对象的地址的距离（以字节为单位）预取到高速缓存中。每个Java线程都有自己的分配点。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:InlineSmallCode=n</td><td>仅当先前编译的方法生成的本机代码大小小于此值时，才对其进行内联。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:MaxInlineSize=35</td><td>要内联的方法的最大字节码大小。</td></tr><tr><td>-XX:FreqInlineSize=n</td><td>要内联的频繁执行方法的最大字节码大小。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:LoopUnrollLimit=n</td><td>展开循环体，服务器编译器中间表示节点计数小于此值。服务器编译器使用的限制是此值的函数，而不是实际值。默认值因运行JVM的平台而异。</td></tr><tr><td>-XX:InitialTenuringThreshold=7</td><td>设置用于并行年轻收集器中自适应GC大小调整的初始时效阈值。终结阈值是对象在被提升为旧的或终身的一代之前在年轻的集合中存活的次数。</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>设置用于自适应GC大小调整的最大暂定阈值。当前最大值为15.并行收集器的默认值为15，CMS为默认值。</td></tr><tr><td>-Xloggc:<filename></filename></td><td>将GC详细输出记录到指定文件。详细输出由正常的详细GC标志控制。</td></tr><tr><td>-XX:-UseGCLogFileRotation</td><td>启用GC日志轮换，需要-Xloggc。</td></tr><tr><td>-XX:NumberOfGClogFiles=1</td><td>设置旋转日志时要使用的文件数，必须&gt; = 1.旋转的日志文件将使用以下命名方案，<filename> .0，<filename> .1，…，<filename> .n- 1。</filename></filename></filename></td></tr><tr><td>-XX:GCLogFileSize=8K</td><td>日志将在何时旋转日志文件的大小必须&gt; = 8K。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java HotSpot VM选项以下选项分为不同类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#BehavioralOptions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;行为选项会&lt;/a&gt;更改VM的基本行为。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#G1Options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;垃圾优先（G1）垃圾收集选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#PerformanceTuning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;性能调整&lt;/a&gt;选项是旋钮，可用于调整VM性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#DebuggingOptions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调试选项&lt;/a&gt;通常可以跟踪，打印或输出VM信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;G1-垃圾收集选项参数&quot;&gt;&lt;a href=&quot;#G1-垃圾收集选项参数&quot; class=&quot;headerlink&quot; title=&quot;G1 垃圾收集选项参数&quot;&gt;&lt;/a&gt;G1 垃圾收集选项参数&lt;/h3&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>git配置.gitignore</title>
    <link href="http://yoursite.com/2019/07/10/Git/git%E9%85%8D%E7%BD%AE.gitignore/"/>
    <id>http://yoursite.com/2019/07/10/Git/git配置.gitignore/</id>
    <published>2019-07-10T08:41:10.255Z</published>
    <updated>2019-07-10T08:42:14.390Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line">### JRebel ###</span><br><span class="line">rebel.xml</span><br><span class="line">### MAC ###</span><br><span class="line">.DS_Store</span><br><span class="line">### Other ###</span><br><span class="line">logs/</span><br><span class="line">temp/</span><br><span class="line">.mvn/</span><br><span class="line">mvnw</span><br><span class="line">mvnw.cmd</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 性能优化</title>
    <link href="http://yoursite.com/2019/07/07/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Tomcat%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/07/07/性能优化/Tomcat 性能优化/</id>
    <published>2019-07-07T13:14:23.291Z</published>
    <updated>2019-07-07T13:16:01.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h3><h4 id="减少配置优化"><a href="#减少配置优化" class="headerlink" title="减少配置优化"></a>减少配置优化</h4><ul><li><p>场景一：假设当前 REST 应用(微服务)、不需要JSP的情况</p><p>分析：它不需要静态资源，Tomcat 容器静态和动态</p><p>静态处理：<code>DefaultServlet</code></p><ul><li><p>优化方案：通过移除<code>conf/web.xml</code>中的 <code>DefaultServlet</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>动态处理：应用<code>Servlet</code>、<code>JspServlet</code></p><ul><li><p>优化方案一：通过移除<code>conf/web.xml</code>中的 <code>JspServlet</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fork<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xpoweredBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring Web MVC 应用 Servlet：<code>DispatcherServlet</code></p><p>JspServlet：编译并且执行Jsp页面</p><p>DefaultServlet：Tomcat处理静态资源的 Servlet</p></blockquote></li><li><p>优化方案二：移除<code>&lt;welcome-file-list&gt;</code>元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优化方案三：移除 <code>Session</code>设置，即将<code>session-timeout</code>元素值设置为<code>-1</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于微服务/REST应用，不需要 Session，因为不需要状态</p><p>Spring Security OAuth 2.0、JWT</p><p>Session 通过 <code>jsessionId</code>进行用户跟踪，HTTP无状态，需要一个ID与当前用户会话联系。Spring Session HttpSession jessionId 作为 Redis，实现多个机器登录，用户会话不丢失。</p><p>存储方式：Cookie、URL重写、SSL</p></blockquote></li><li><p>优化方案四：移除 <code>conf\server.xml</code>中的 <code>Valve</code>元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Valve</code>类似于 <code>Filter</code> </p><p>移除<code>AccessLogValue</code>，可以通过<code>Nginx</code>的<code>Access</code>替代</p></blockquote></li></ul></li><li><p>场景二：需要JSP的情况</p><p>分析：<code>JspServlet</code>无法移除，了解<code>JspServlet</code>处理原理  </p><blockquote><p>Servlet 周期：</p><ul><li>实例化：Servlet 和 Filter 实现类必须包含默认构造器。反射的方式进行实例化</li><li>初始化：Servlet 容器调用 Servlet 或 Filter init() 方法</li><li>销毁：Servlet 容器关闭时，Servlet 或者 Filter destory() 方法被调用</li></ul><p>Servlet 或者 Filter 在一个容器中，一般情况下在一个 Web App 中是一个单例，不排除应用定义多个。</p></blockquote><p>JspServlet 相关优化参数：</p></li><li><p>需要编译</p><ul><li><code>compiler</code></li><li><code>modificationTestInterval</code></li></ul></li><li><p>不需要编译</p><ul><li><p><code>development</code>设置为 <code>false</code></p><blockquote><p>development = false ，那么，这些 JSP 编译优化方法：</p><ul><li><p>Ant Task 执行 JSP 编译</p></li><li><p>Maven 插件：GAV如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.codehaus.mojo.jspc/jspc-maven-plugin --&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo.jspc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jspc-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0-alpha-3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul></li></ul><blockquote><p><strong>总结：</strong><code>conf/web.xml</code>作为 Servlet 应用的默认<code>web.xml</code>，实际上，应用程序存在两份<code>web.xml</code>，其中包括应用的<code>web.xml</code>，最终将两者合并</p><p>JspServlet 如果 development 参数为 true，它会自定检查文件是否修改，如果修改重新翻译，再编译(加载和执行)。言外之意，JspServlet 开发模式可能会导致内存溢出(卸载 Class 不及时所导致 Perm 区域不够)。</p></blockquote><h3 id="配置调整"><a href="#配置调整" class="headerlink" title="配置调整"></a>配置调整</h3><h4 id="关闭自动重载"><a href="#关闭自动重载" class="headerlink" title="关闭自动重载"></a>关闭自动重载</h4><p>修改<code>conf/server.xml</code>中的<code>&lt;Context&gt;</code>标签中的<code>reloadable</code>属性为<code>false</code>(如果是单独的<code>context.xml</code>文件，则修改该文件中的相关属性值)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"$&#123;AppAbsolutePath&#125;"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改连接线程池数量"><a href="#修改连接线程池数量" class="headerlink" title="修改连接线程池数量"></a>修改连接线程池数量</h4><p>通过修改<code>conf/server.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">minSpareThreads</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;Executor&gt;</code>实际的Tomcat接口</p><ul><li><p><code>org.apache.catalina.Executor</code>，</p><ul><li><p>扩展了J.U.C标准接口<code>java.util.concurrent.Executor</code>，</p></li><li><p>实现<code>org.apache.catalina.core.StandardThreadExecutor</code></p><ul><li><p>线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* max number of threads</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> maxThreads = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* min number of threads</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> minSpareThreads = <span class="number">25</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxThreads</span><span class="params">(<span class="keyword">int</span> maxThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxThreads = maxThreads;</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor.setMaximumPoolSize(maxThreads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinSpareThreads</span><span class="params">(<span class="keyword">int</span> minSpareThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.minSpareThreads = minSpareThreads;</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor.setCorePoolSize(minSpareThreads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池：<code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>(<code>java.util.concurrent.ThreadPoolExecutor</code>)</p></li><li><p><strong>总结：</strong>Tomcat IO 连接器使用的线程池实际是标准的 <code>Java</code> 线程池的扩展，最大线程数量和最小线程数量实际上分别是 <code>MaximumPoolSize</code>和 <code>CorePoolSize</code>。</p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置优化&quot;&gt;&lt;a href=&quot;#配置优化&quot; class=&quot;headerlink&quot; title=&quot;配置优化&quot;&gt;&lt;/a&gt;配置优化&lt;/h3&gt;&lt;h4 id=&quot;减少配置优化&quot;&gt;&lt;a href=&quot;#减少配置优化&quot; class=&quot;headerlink&quot; title=&quot;减少配置优化&quot;&gt;&lt;/a&gt;减少配置优化&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;场景一：假设当前 REST 应用(微服务)、不需要JSP的情况&lt;/p&gt;
&lt;p&gt;分析：它不需要静态资源，Tomcat 容器静态和动态&lt;/p&gt;
&lt;p&gt;静态处理：&lt;code&gt;DefaultServlet&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优化方案：通过移除&lt;code&gt;conf/web.xml&lt;/code&gt;中的 &lt;code&gt;DefaultServlet&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.catalina.servlets.DefaultServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;debug&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;listings&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Tomcat 优化" scheme="http://yoursite.com/tags/Tomcat-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat Maven 插件</title>
    <link href="http://yoursite.com/2019/07/07/devNote/Tomcat8%20Maven%20%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/07/07/devNote/Tomcat8 Maven 插件/</id>
    <published>2019-07-07T01:49:35.089Z</published>
    <updated>2019-07-07T13:07:00.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tomcat7-Maven-插件地址"><a href="#Tomcat7-Maven-插件地址" class="headerlink" title="Tomcat7 Maven 插件地址"></a>Tomcat7 Maven 插件地址</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.maven/tomcat7-maven-plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Tomcat8-Maven-插件地址"><a href="#Tomcat8-Maven-插件地址" class="headerlink" title="Tomcat8 Maven 插件地址"></a>Tomcat8 Maven 插件地址</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.maven/tomcat8-maven-plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat8-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0-r1756463<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tomcat7-Maven-插件地址&quot;&gt;&lt;a href=&quot;#Tomcat7-Maven-插件地址&quot; class=&quot;headerlink&quot; title=&quot;Tomcat7 Maven 插件地址&quot;&gt;&lt;/a&gt;Tomcat7 Maven 插件地址&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Tomcat8" scheme="http://yoursite.com/categories/Tomcat8/"/>
    
    
      <category term="Tomcat8 Plugin" scheme="http://yoursite.com/tags/Tomcat8-Plugin/"/>
    
  </entry>
  
  <entry>
    <title>从实际案例聊聊Java应用的GC优化</title>
    <link href="http://yoursite.com/2019/07/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/07/06/性能优化/从实际案例聊聊Java应用的GC优化/</id>
    <published>2019-07-06T13:17:04.906Z</published>
    <updated>2019-07-06T13:31:45.048Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p><p>当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。但GC算法复杂，影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度。即便如此，GC调优也不是无章可循，仍然有一些通用的思考方法。本篇会介绍这些通用的GC优化策略和相关实践案例，主要包括如下内容：</p><blockquote><p>优化方法: 介绍调优的一般流程：明确优化目标→优化→跟踪优化结果。 &gt; 优化案例: 简述笔者所在团队遇到的GC问题以及优化方案。</p></blockquote><h2 id="一、优化前的准备"><a href="#一、优化前的准备" class="headerlink" title="一、优化前的准备"></a>一、优化前的准备</h2><a id="more"></a><h3 id="GC优化需知"><a href="#GC优化需知" class="headerlink" title="GC优化需知"></a>GC优化需知</h3><p>为了更好地理解本篇所介绍的内容，你需要了解如下内容。 1. GC相关基础知识，包括但不限于： a) GC工作原理。 b) 理解新生代、老年代、晋升等术语含义。 c) 可以看懂GC日志。</p><ol><li>GC优化不能解决一切性能问题，它是最后的调优手段。</li></ol><p>如果对第一点中提及的知识点不是很熟悉，可以先阅读小结-JVM基础回顾；如果已经很熟悉，可以跳过该节直接往下阅读。</p><h3 id="JVM基础回顾"><a href="#JVM基础回顾" class="headerlink" title="JVM基础回顾"></a>JVM基础回顾</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><p>简单介绍一下JVM内存结构和常见的垃圾回收器。</p><p>当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。</p><p>Hotspot VM将内存划分为不同的物理区，就是“分代”思想的体现。如图所示，JVM内存主要由新生代、老年代、永久代构成。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/1.png"></p><ol><li>新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。</li><li>老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</li><li>永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。</li></ol><h4 id="常见垃圾回收器"><a href="#常见垃圾回收器" class="headerlink" title="常见垃圾回收器"></a>常见垃圾回收器</h4><p>不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：</p><ul><li>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。</li><li>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</li><li>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。</li><li>并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</li></ul><h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p>每一种回收器的日志格式都是由其自身的实现决定的，换而言之，每种回收器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个回收器的日志都维持一定的共性。<a href="https://www.jianshu.com/p/176bd8634e46" target="_blank" rel="noopener">JavaGC日志</a> 中简单介绍了这些共性。</p><h3 id="参数基本策略"><a href="#参数基本策略" class="headerlink" title="参数基本策略"></a>参数基本策略</h3><p>各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p><p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下（见参考文献1）：</p><table><thead><tr><th style="text-align:left">空间</th><th style="text-align:left">倍数</th></tr></thead><tbody><tr><td style="text-align:left">总大小</td><td style="text-align:left"><strong>3-4</strong> 倍活跃数据的大小</td></tr><tr><td style="text-align:left">新生代</td><td style="text-align:left"><strong>1-1.5</strong> 活跃数据的大小</td></tr><tr><td style="text-align:left">老年代</td><td style="text-align:left"><strong>2-3</strong> 倍活跃数据的大小</td></tr><tr><td style="text-align:left">永久代</td><td style="text-align:left"><strong>1.2-1.5</strong> 倍Full GC后的永久代空间占用</td></tr></tbody></table><p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p><blockquote><p>总堆：1200MB = 300MB × 4<em> 新生代：450MB = 300MB × 1.5</em> 老年代： 750MB = 1200MB - 450MB*</p></blockquote><p>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</p><h2 id="二、优化步骤"><a href="#二、优化步骤" class="headerlink" title="二、优化步骤"></a>二、优化步骤</h2><p>GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。</p><h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： - 高可用，可用性达到几个9。 - 低延迟，请求必须多少毫秒内完成响应。 - 高吞吐，每秒完成多少次事务。</p><p>明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。</p><p>由于笔者所在团队主要关注高可用和低延迟两项指标，所以接下来分析，如何量化GC时间和频率对于响应时间和可用性的影响。通过这个量化指标，可以计算出当前GC情况对服务的影响，也能评估出GC优化后对响应时间的收益，这两点对于低延迟服务很重要。</p><p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/2.png"></p><p>那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，<strong>受GC影响请求占比=(接口响应时间+GC时间)×N/T</strong> 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。</p><p>进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。</p><h3 id="验收优化结果"><a href="#验收优化结果" class="headerlink" title="验收优化结果"></a>验收优化结果</h3><p>将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验。</p><p>接下来，我们通过三个案例来实践以上的优化流程和基本原则（本文中三个案例使用的垃圾回收器均为ParNew+CMS，CMS失败时Serial Old替补)。</p><h2 id="三、GC优化案例"><a href="#三、GC优化案例" class="headerlink" title="三、GC优化案例"></a>三、GC优化案例</h2><h3 id="案例一-Major-GC和Minor-GC频繁"><a href="#案例一-Major-GC和Minor-GC频繁" class="headerlink" title="案例一 Major GC和Minor GC频繁"></a>案例一 Major GC和Minor GC频繁</h3><h4 id="确定目标-1"><a href="#确定目标-1" class="headerlink" title="确定目标"></a>确定目标</h4><p>服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。</p><p>由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。</p><p><em>（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3%</em> 。</p><p>优化目标：降低TP99、TP90时间。</p><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p><p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？ 首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/3.png"></p><ul><li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。</li><li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。</li></ul><p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/4.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/4.png"></p><p>通过上图GC日志中两处红色框标记内容可知： 1. new threshold = 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。 2. Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% = 2G/2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。</p><p>由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。</p><h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><p>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p><p>调整前：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/5.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/5.png"></p><p>调整后：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/6.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/6.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如何选择各分区大小应该依赖应用程序中<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p><h4 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h4><p>关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold=15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。</p><p><strong>动态年龄计算</strong>：Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 = 64M，desired survivor = 32M，此时Survivor区中age&lt;=2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p><p>JVM引入动态年龄计算，主要基于如下两点考虑：</p><ol><li>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件： a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。 b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</li><li>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</li></ol><p>总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p><h3 id="案例二-请求高峰期发生GC，导致服务可用性下降"><a href="#案例二-请求高峰期发生GC，导致服务可用性下降" class="headerlink" title="案例二 请求高峰期发生GC，导致服务可用性下降"></a>案例二 请求高峰期发生GC，导致服务可用性下降</h3><h4 id="确定目标-2"><a href="#确定目标-2" class="headerlink" title="确定目标"></a>确定目标</h4><p>GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/7.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/7.png"></p><h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><p>解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。 1. Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。 2. Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。 3. Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。 4. 并发清理，进行并发的垃圾清理。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/8.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/8.png"></p><p>可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/9.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/9.png"></p><p>如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。 新生代对象持有老年代中对象的引用，这种情况称为<strong>“跨代引用”</strong>。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。</p><p>灰色对象已经不可达，但仍然需要扫描的原因：<strong>新生代GC和老年代的GC是各自分开独立进行的</strong>，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时&gt;500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p><p>新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。CMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。</p><p>除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。 根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。</p><p>对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。</p><h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><p>经过增加CMSScavengeBeforeRemark参数，单次执行时间&gt;200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/10.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/10.png"></p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。</p><h4 id="更多思考-1"><a href="#更多思考-1" class="headerlink" title="更多思考"></a>更多思考</h4><p>案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p><p><strong>JVM是如何避免Minor GC时扫描全堆的？</strong> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/11.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/11.png"></p><p><strong>卡表</strong>的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p><p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p><h3 id="案例三-发生Stop-The-World的GC"><a href="#案例三-发生Stop-The-World的GC" class="headerlink" title="案例三 发生Stop-The-World的GC"></a>案例三 发生Stop-The-World的GC</h3><h4 id="确定目标-3"><a href="#确定目标-3" class="headerlink" title="确定目标"></a>确定目标</h4><p>GC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。本次优化目标是降低单次STW回收停顿时间，提高可用性。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/性能优化/从实际案例聊聊Java应用的GC优化/12.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B%E8%81%8A%E8%81%8AJava%E5%BA%94%E7%94%A8%E7%9A%84GC%E4%BC%98%E5%8C%96/12.png"></p><h4 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h4><p>首先，什么时候可能会触发STW的Full GC呢？ 1. Perm空间不足； 2. CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）； 3. 统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间； 4. 主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</p><p>然后，我们来逐一分析一下： - 排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。 - 排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。 - 排除原因4：因为当时没有相关命令执行。 - 锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。</p><p>找到原因后解决方法有两种： 1. 通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。 2. CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。</p><p>由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。</p><h4 id="优化结果-2"><a href="#优化结果-2" class="headerlink" title="优化结果"></a>优化结果</h4><p>调整参数后，服务不再有Perm区扩容导致的STW GC发生。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>结合上述GC优化案例做个总结： 1. 首先再次声明，在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间。我们不能指望一个系统架构有缺陷或者代码层次优化没有穷尽的应用，通过GC优化令其性能达到一个质的飞跃。 2. 其次，通过上述分析，可以看出虚拟机内部已有很多优化来保证应用的稳定运行，所以不要为了调优而调优，不当的调优可能适得其反。 3. 最后，GC优化是一个系统而复杂的工作，没有万能的调优策略可以满足所有的性能指标。GC优化必须建立在我们深入理解各种垃圾回收器的基础上，才能有事半功倍的效果。</p><p>本文中案例均来北京业务安全中心（也称风控）对接服务的实践经验。同时感谢风控的小伙伴们，是他们专业负责的审阅，才让这篇文章更加完善。对于本文中涉及到的内容，欢迎大家指正和补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://tech.meituan.com/2017/12/29/jvm-optimize.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.meituan.com/2017/12/29/jvm-optimize.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。但GC算法复杂，影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度。即便如此，GC调优也不是无章可循，仍然有一些通用的思考方法。本篇会介绍这些通用的GC优化策略和相关实践案例，主要包括如下内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优化方法: 介绍调优的一般流程：明确优化目标→优化→跟踪优化结果。 &amp;gt; 优化案例: 简述笔者所在团队遇到的GC问题以及优化方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、优化前的准备&quot;&gt;&lt;a href=&quot;#一、优化前的准备&quot; class=&quot;headerlink&quot; title=&quot;一、优化前的准备&quot;&gt;&lt;/a&gt;一、优化前的准备&lt;/h2&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="GC优化" scheme="http://yoursite.com/tags/GC%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(七)使用MAT的Histogram和Dominator Tree定位溢出源</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E4%B8%83)%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(七)使用MAT的Histogram和Dominator Tree定位溢出源/</id>
    <published>2019-07-06T12:28:22.174Z</published>
    <updated>2019-07-06T13:17:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>先列出几个基础的概念：</p><h3 id="Shallow-Heap-和-Retained-Heap"><a href="#Shallow-Heap-和-Retained-Heap" class="headerlink" title="Shallow Heap 和 Retained Heap"></a>Shallow Heap 和 Retained Heap</h3><p>Shallow Heap表示对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和。</p><p>Retained Heap是该对象自己的Shallow Heap，并加上从该对象能直接或间接访问到对象的Shallow Heap之和。换句话说，Retained Heap是该对象GC之后所能回收到内存的总和。</p><p>把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain的起点。</p><a id="more"></a><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/1.png"></p><p>从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。obj2的retained size可以通过相同的方式计算。</p><h3 id="对象引用（Reference）"><a href="#对象引用（Reference）" class="headerlink" title="对象引用（Reference）"></a>对象引用（Reference）</h3><p>对象引用按从最强到最弱有如下级别，不同的引用（可到达性）级别反映了对象的生命周期：</p><ul><li><strong>强引用（Strong Ref）</strong>：通常我们编写的代码都是强引用，于此相对应的是强可达性，只有去掉强可达性，对象才能被回收。</li><li><strong>软引用（Soft Ref）</strong>：对应软可达性，只要有足够的内存就一直保持对象，直到发现内存不足且没有强引用的时候才回收对象。</li><li><strong>弱引用（Weak Ref）</strong>：比软引用更弱，当发现不存在强引用的时候会立即回收此类型的对象，而不需要等到内存不足。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。</li><li><strong>虚引用（Phantom Ref）</strong>：根本不会在内存中保持该类型的对象，只能使用虚引用本身，一般用于在进入finalize()方法后进行特殊的清理过程，通过java.lang.ref.PhantomReference实现。</li></ul><h3 id="GC-Roots和Reference-Chain"><a href="#GC-Roots和Reference-Chain" class="headerlink" title="GC Roots和Reference Chain"></a>GC Roots和Reference Chain</h3><p>JVM在进行GC的时候是通过使用可达性来判断对象是否存活，通过GC Roots（GC根节点）的对象作为起始点，从这些节点开始进行向下搜索，搜索所走过的路径成为Reference Chain（引用链），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>如下图所示，对象object 5、object 6、object 7虽然互相有关联，它们的引用并不为0，但是它们到GC Roots是不可达的，因此它们将会被判定为是可回收的对象。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/2.jpg" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/2.png"></p><h2 id="Histogram（直方图）视图"><a href="#Histogram（直方图）视图" class="headerlink" title="Histogram（直方图）视图"></a>Histogram（直方图）视图</h2><p>点击工具栏上的 <code>Histogram</code>图标可以打开 Histogram（直方图）视图，可以列出每个类产生的实例数量，以及所占用的内存大小和百分比。主界面如下图所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/3.png"></p><p>图中Shallow Heap 和 Retained Heap分别表示对象自身不包含引用的大小和对象自身并包含引用的大小，具体请参考下面 <a href="https://www.javatang.com/archives/2017/11/08/11582145.html#Shallow_Heap_Retained_Heap" target="_blank" rel="noopener">Shallow Heap 和 Retained Heap</a> 部分的内容。默认的大小单位是 Bytes，可以在 Window - Preferences 菜单中设置单位，图中设置的是KB。</p><p>通过直方图视图可以很容易找到占用内存最多的几个类（通过Retained Heap排序），还可以通过其他方式进行分组（见下图）。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/4.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/4.png"></p><p>如果存在内存溢出，时间久了溢出类的实例数量或者内存占比会越来越多，排名也越来越靠前。可以点击工具类上的右上角图标进行对比，通过多次对比不同时间点下的直方图对比就很容易把溢出的类找出来。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/5.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/5.png"></p><p>还有一种对比直方图的方式，首先通过 Window 菜单打开 Navigation History 视图，选中直方图右键并选中 Add to Compare Basket项目，将直方图添加到 Compare Basket 中。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/6.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/6.png"></p><p>然后在 Compare Basket 中点击右上角的 <code>红色感叹号</code> 按钮，可以分别列出对比的所有结果，见下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/7.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/7.png"></p><p>并且在上面的可以设置不同的对比方式。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/8.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/8.png"></p><h2 id="Dominator-Tree视图"><a href="#Dominator-Tree视图" class="headerlink" title="Dominator Tree视图"></a>Dominator Tree视图</h2><p>点击工具栏上的<code>Dominator Tree</code>图标可以打开Dominator Tree（支配树）视图，在此视图中列出了每个对象（Object Instance）与其引用关系的树状结构，同时包含了占用内存的大小和百分比。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/9.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/9.png"></p><p>通过Dominator Tree视图可以很容易的找出占用内存最多的几个对象（根据Retained Heap或Percentage排序），和Histogram类似，可以通过不同的方式进行分组显示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/10.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/10.png"></p><h2 id="定位溢出源"><a href="#定位溢出源" class="headerlink" title="定位溢出源"></a>定位溢出源</h2><p>Histogram视图和Dominator Tree视图的角度不同，前者是基于类的角度，后者是基于对象实例的角度，并且可以更方便的看出其引用关系。</p><p>首先，在两个视图中找出疑似溢出的对象或者类（可以通过Retained Heap排序，并且可以在Class Name中输入正则表达式的关键词只显示指定的类名），然后右键选择Path To GC Roots（Histogram中没有此项）或Merge Shortest Paths to GC Roots，然后选择 <em>exclude all phantom/weak/soft etc. reference</em>：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/11.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/11.png"></p><p>GC Roots意为GC根节点，其含义见上面的 <a href="https://www.javatang.com/archives/2017/11/08/11582145.html#GC_RootsReference_Chain" target="_blank" rel="noopener">GC Roots和Reference Chain</a> 部分，后面的 <em>exclude all phantom/weak/soft etc. reference</em> 意思是排除<a href="https://www.javatang.com/archives/2017/11/08/11582145.html#Reference" target="_blank" rel="noopener">虚引用、弱引用和软引用</a>，即只剩下<a href="https://www.javatang.com/archives/2017/11/08/11582145.html#Reference" target="_blank" rel="noopener">强引用</a>，因为除了强引用之外，其他的引用都可以被JVM GC掉，如果一个对象始终无法被GC，就说明有强引用存在，从而导致在GC的过程中一直得不到回收，最终就内存溢出了。</p><p>通过结果就可以很方便的定位到具体的代码，然后分析是什么原因无法释放该对象，比如被缓存了或者没有使用单例模式等等。</p><p>下面是执行的结果：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用MAT的Histogram和Dominator Tree定位溢出源/12.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8MAT%E7%9A%84Histogram%E5%92%8CDominator%20Tree%E5%AE%9A%E4%BD%8D%E6%BA%A2%E5%87%BA%E6%BA%90/12.png"></p><p>上图中保留了大量的VelocitySqlBulder的外部引用，后来查看了代码，原来每次调用的时候都实例化一个新的对象，由于VelocitySqlBulder类是无状态的工具类，因此修改为单例方式就可以解决这个问题。</p><h2 id="后续观察"><a href="#后续观察" class="headerlink" title="后续观察"></a>后续观察</h2><p>根据上面分析的结果对问题进行处理之后，再对照之前的操作，看看对象是否还再持续增长，如果没有就说明这个地方的问题已经解决了。</p><p>最后再<a href="http://www.javatang.com/archives/2017/10/20/12131956.html#jstat" target="_blank" rel="noopener">用 jstat 持续跟踪</a>一段时间，看看<a href="http://www.javatang.com/archives/2017/10/20/12131956.html#JVM" target="_blank" rel="noopener">Old和Perm区的内存</a>是否最终稳定在一个范围之内，如果长时间稳定在一个范围说明溢出问题得到了解决，否则还要继续进行分析和处理，一直到稳定为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;p&gt;先列出几个基础的概念：&lt;/p&gt;
&lt;h3 id=&quot;Shallow-Heap-和-Retained-Heap&quot;&gt;&lt;a href=&quot;#Shallow-Heap-和-Retained-Heap&quot; class=&quot;headerlink&quot; title=&quot;Shallow Heap 和 Retained Heap&quot;&gt;&lt;/a&gt;Shallow Heap 和 Retained Heap&lt;/h3&gt;&lt;p&gt;Shallow Heap表示对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和。&lt;/p&gt;
&lt;p&gt;Retained Heap是该对象自己的Shallow Heap，并加上从该对象能直接或间接访问到对象的Shallow Heap之和。换句话说，Retained Heap是该对象GC之后所能回收到内存的总和。&lt;/p&gt;
&lt;p&gt;把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain的起点。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(六)JVM Heap Dump（堆转储文件）的生成和MAT的使用</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E5%85%AD)JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(六)JVM Heap Dump（堆转储文件）的生成和MAT的使用/</id>
    <published>2019-07-06T12:19:38.489Z</published>
    <updated>2019-07-06T13:18:18.423Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="JVM-Heap-Dump（堆转储文件）的生成"><a href="#JVM-Heap-Dump（堆转储文件）的生成" class="headerlink" title="JVM Heap Dump（堆转储文件）的生成"></a>JVM Heap Dump（堆转储文件）的生成</h2><p>正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。<br>可以通过以下几种方式生成Heap Dump文件：</p><h3 id="使用-jmap-命令生成"><a href="#使用-jmap-命令生成" class="headerlink" title="使用 jmap 命令生成"></a>使用 jmap 命令生成</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html" target="_blank" rel="noopener">jmap</a> 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap-dump.bin &lt;pid&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中的pid是JVM进程的id，<code>heap-dump.bin</code>是生成的文件名称，在执行命令的目录下面。推荐此种方法。</p><h3 id="使用-JConsole-生成"><a href="#使用-JConsole-生成" class="headerlink" title="使用 JConsole 生成"></a>使用 JConsole 生成</h3><p>JConsole是JDK提供的一个基于GUI查看JVM系统信息的工具，既可以管理本地的JVM，也可以管理远程的JVM，可以通过下图的 <code>dumpHeap</code> 按钮生成 Heap Dump文件。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/1.png"></p><h3 id="在JVM中增加参数生成"><a href="#在JVM中增加参数生成" class="headerlink" title="在JVM中增加参数生成"></a>在JVM中增加参数生成</h3><p>在JVM的配置参数中可以添加 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数，当应用抛出 OutOfMemoryError 时自动生成dump文件；<br>在JVM的配置参数中添加 <code>-Xrunhprof:head=site</code> 参数，会生成java.hprof.txt 文件，不过这样会影响JVM的运行效率，不建议在生产环境中使用（未亲测）。</p><h2 id="常见的Heap-Dump文件分析工具"><a href="#常见的Heap-Dump文件分析工具" class="headerlink" title="常见的Heap Dump文件分析工具"></a>常见的Heap Dump文件分析工具</h2><p>JVM Heap Dump文件可以使用常用的分析工具如下：</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a> 是JDK自带的用于分析JVM Heap Dump文件的工具，使用下面的命令可以将堆文件的分析结果以HTML网页的形式进行展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat &lt;heap-dump-file&gt;</span><br></pre></td></tr></table></figure><p>其中 heap-dump-file 是文件的路径和文件名，可以使用 <code>-J-Xmx512m</code> 参数设置命令的内存大小。执行成功之后显示如下结果：</p><blockquote><p>Snapshot resolved.<br>Started HTTP server on port 7000<br>Server is ready.</p></blockquote><p>这个时候访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a> 就可以看到结果了。</p><h3 id="Eclipse-Memory-Analyzer-MAT"><a href="#Eclipse-Memory-Analyzer-MAT" class="headerlink" title="Eclipse Memory Analyzer(MAT)"></a>Eclipse Memory Analyzer(MAT)</h3><p><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer(MAT)</a>是Eclipse提供的一款用于Heap Dump文件的工具，操作简单明了，下面将详细进行介绍。</p><h3 id="IBM-Heap-Analyzer"><a href="#IBM-Heap-Analyzer" class="headerlink" title="IBM Heap Analyzer"></a>IBM Heap Analyzer</h3><p><a href="https://www.ibm.com/developerworks/community/alphaworks/tech/heapanalyzer" target="_blank" rel="noopener">IBM Heap Analyzer</a> 是IBM公司推出的一款用于分析Heap Dump信息的工具，下载之后是一个jar文件，执行结果如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/2.png"></p><h2 id="Memory-Analyzer的安装和使用"><a href="#Memory-Analyzer的安装和使用" class="headerlink" title="Memory Analyzer的安装和使用"></a>Memory Analyzer的安装和使用</h2><p>如前文所述，Eclipse Memory Analyzer（简称MAT）是一个功能丰富且操作简单的JVM Heap Dump分析工具，可以用来辅助发现内存泄漏减少内存占用。<br>使用 Memory Analyzer 来分析生产环境的 Java 堆转储文件，可以从数以百万计的对象中快速计算出对象的 Retained Size，查看是谁在阻止垃圾回收，并自动生成一个 Leak Suspect（内存泄露可疑点）报表。</p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>Eclipse Memory Analyzer（MAT）支持两种安装方式，一是Eclipse插件的方式，另外一个就是独立运行的方式，建议使用独立运行的方式。<br>在 <a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">http://www.eclipse.org/mat/downloads.php</a> 下载安装MAT，启动之后打开 File - Open Heap Dump… 菜单，然后选择生成的Heap DUmp文件，选择 “Leak Suspects Report”，然后点击 “Finish” 按钮。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/3.png"></p><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>第一次打开因为需要分析dump文件，所以需要等待一段时间进行分析，分析完成之后dump文件目录下面的文件信息如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/4.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/4.png"></p><p>上图中 heap-27311.bin 文件是原始的Heap Dump文件，zip文件是生成的html形式的报告文件。</p><p>打开之后，主界面如下所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/5.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/5.png"></p><p>接下来介绍界面中常用到的功能：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/6.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/6.png"></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Overview视图，即概要界面，显示了概要的信息，并展示了MAT常用的一些功能。</p><ul><li>Details 显示了一些统计信息，包括整个堆内存的大小、类（Class）的数量、对象（Object）的数量、类加载器（Class Loader)的数量。</li><li>Biggest Objects by Retained Size 使用饼图的方式直观地显示了在JVM堆内存中最大的几个对象，当光标移到饼图上的时候会在左边Inspector和Attributes窗口中显示详细的信息。</li><li>Actions 这里显示了几种常用到的操作，算是功能的快捷方式，包括 Histogram、Dominator Tree、Top Consumers、Duplicate Classes，具体的含义和用法见下面；</li><li>Reports 列出了常用的报告信息，包括 Leak Suspects和Top Components，具体的含义和内容见下；</li><li>Step By Step 以向导的方式引导使用功能。</li></ul><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><p>直方图，可以查看每个类的实例（即对象）的数量和大小。</p><h3 id="Dominator-Tree"><a href="#Dominator-Tree" class="headerlink" title="Dominator Tree"></a>Dominator Tree</h3><p>支配树，列出Heap Dump中处于活跃状态中的最大的几个对象，默认按 retained size进行排序，因此很容易找到占用内存最多的对象。</p><h3 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h3><p>MAT提供了一个对象查询语言（OQL），跟SQL语言类似，将类当作表、对象当作记录行、成员变量当作表中的字段。通过OQL可以方便快捷的查询一些需要的信息，是一个非常有用的工具。</p><h3 id="Thread-Overview"><a href="#Thread-Overview" class="headerlink" title="Thread Overview"></a>Thread Overview</h3><p>此工具可以查看生成Heap Dump文件的时候线程的运行情况，用于线程的分析。</p><h3 id="Run-Expert-System-Test"><a href="#Run-Expert-System-Test" class="headerlink" title="Run Expert System Test"></a>Run Expert System Test</h3><p>可以查看分析完成的HTML形式的报告，也可以打开已经产生的分析报告文件，子菜单项如下图所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/7.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/7.png"></p><p>常用的主要有Leak Suspects和Top Components两种报告：</p><ul><li>Leak Suspects 可以说是非常常用的报告了，该报告分析了 Heap Dump并尝试找出内存泄漏点，最后在生成的报告中对检测到的可疑点做了详细的说明；</li><li>Top Components 列出占用总堆内存超过1%的对象。</li></ul><h3 id="Open-Query-Browser"><a href="#Open-Query-Browser" class="headerlink" title="Open Query Browser"></a>Open Query Browser</h3><p>提供了在分析过程中用到的工具，通常都集成在了右键菜单中，在后面具体举例分析的时候会做详细的说明。如下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/8.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/8.png"></p><p>这里仅针对在 Overview 界面中的 Acations中列出的两项进行说明：</p><ul><li><p>Top Consumers 按类、类加载器和包分别进行查询，并以饼图的方式列出最大的几个对象。菜单打开方式如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/9.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/9.png"></p></li><li><p>Duplicate Classes 列出被加载多次的类，结果按类加载器进行分组，目标是加载同一个类多次被类加载器加载。使用该工具很容易找到部署应用的时候使用了同一个库的多个版本。菜单打开方式如下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/10.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/10.png"></p></li></ul><h3 id="Find-Object-by-address"><a href="#Find-Object-by-address" class="headerlink" title="Find Object by address"></a>Find Object by address</h3><p>通过十六进制的地址查找对应的对象，见下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/JVM Heap Dump（堆转储文件）的生成和MAT的使用/11.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/JVM%20Heap%20Dump%EF%BC%88%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8CMAT%E7%9A%84%E4%BD%BF%E7%94%A8/11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM-Heap-Dump（堆转储文件）的生成&quot;&gt;&lt;a href=&quot;#JVM-Heap-Dump（堆转储文件）的生成&quot; class=&quot;headerlink&quot; title=&quot;JVM Heap Dump（堆转储文件）的生成&quot;&gt;&lt;/a&gt;JVM Heap Dump（堆转储文件）的生成&lt;/h2&gt;&lt;p&gt;正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。&lt;br&gt;可以通过以下几种方式生成Heap Dump文件：&lt;/p&gt;
&lt;h3 id=&quot;使用-jmap-命令生成&quot;&gt;&lt;a href=&quot;#使用-jmap-命令生成&quot; class=&quot;headerlink&quot; title=&quot;使用 jmap 命令生成&quot;&gt;&lt;/a&gt;使用 jmap 命令生成&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jmap&lt;/a&gt; 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jmap -dump:live,format=b,file=heap-dump.bin &amp;lt;pid&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(五)常见的Thread Dump日志案例分析</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E4%BA%94)%E5%B8%B8%E8%A7%81%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(五)常见的Thread Dump日志案例分析/</id>
    <published>2019-07-06T12:16:21.192Z</published>
    <updated>2019-07-06T13:18:10.451Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="症状及解决方案"><a href="#症状及解决方案" class="headerlink" title="症状及解决方案"></a>症状及解决方案</h2><p>下面列出几种常见的症状即对应的解决方案：</p><h3 id="CPU占用率很高，响应很慢"><a href="#CPU占用率很高，响应很慢" class="headerlink" title="CPU占用率很高，响应很慢"></a>CPU占用率很高，响应很慢</h3><p>按照<a href="http://www.javatang.com/archives/2017/10/19/33151873.html" target="_blank" rel="noopener">《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》</a>中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。<br>在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。<a href="http://www.javatang.com/archives/2017/10/20/12131956.html" target="_blank" rel="noopener">如果线程指向的是”VM Thread”</a>或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。</p><a id="more"></a><h3 id="CPU占用率不高，但响应很慢"><a href="#CPU占用率不高，但响应很慢" class="headerlink" title="CPU占用率不高，但响应很慢"></a>CPU占用率不高，但响应很慢</h3><p>在整个请求的过程中多次执行Thread Dump然后进行对比，取得 <code>BLOCKED</code> 状态的线程列表，通常是因为线程停在了I/O、数据库连接或网络连接的地方。</p><h2 id="关注点概况"><a href="#关注点概况" class="headerlink" title="关注点概况"></a>关注点概况</h2><p>在Thread Dump文件中，线程的状态分成两种：<a href="http://www.javatang.com/archives/2017/10/25/36441958.html#_Native_Thread_Status" target="_blank" rel="noopener">Native Thread Status</a>和<a href="http://www.javatang.com/archives/2017/10/25/36441958.html#JVM_JVM_Thread_Status" target="_blank" rel="noopener">JVM Thread Status</a>，具体的含义可以参考上一篇文章。在分析日志的时候需要重点关注如下几种线程状态：</p><h3 id="系统线程状态为-deadlock"><a href="#系统线程状态为-deadlock" class="headerlink" title="系统线程状态为 deadlock"></a>系统线程状态为 <a href="http://www.javatang.com/archives/2017/10/25/36441958.html#deadlock" target="_blank" rel="noopener">deadlock</a></h3><p>线程处于死锁状态，将占用系统大量资源。</p><h3 id="系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait"><a href="#系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait" class="headerlink" title="系统线程状态为 waiting for monitor entry 或 in Object.wait()"></a>系统线程状态为 <a href="http://www.javatang.com/archives/2017/10/25/36441958.html#waiting_for_monitor_entry_in_Objectwait" target="_blank" rel="noopener">waiting for monitor entry 或 in Object.wait()</a></h3><p>如上一篇文章中所说，系统线程处于这种状态说明它在等待进入一个临界区，此时JVM线程的状态通常都是 java.lang.Thread.State: BLOCKED。</p><p>如果大量线程处于这种状态的话，可能是一个全局锁阻塞了大量线程。如果短期内多次打印Thread Dump信息，发现 <code>waiting for monitor entry</code> 状态的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆得时间太长了，以至于越来越多新线程迟迟无法进入。</p><h3 id="系统线程状态为-waiting-on-condition"><a href="#系统线程状态为-waiting-on-condition" class="headerlink" title="系统线程状态为 waiting on condition"></a>系统线程状态为 <a href="http://www.javatang.com/archives/2017/10/25/36441958.html#waiting_on_condition" target="_blank" rel="noopener">waiting on condition</a></h3><p>系统线程处于此种状态说明它在等待另一个条件的发生来唤醒自己，或者自己调用了sleep()方法。此时JVM线程的状态通常是java.lang.Thread.State: WAITING (parking)（等待唤醒条件）或java.lang.Thread.State: TIMED_WAITING (parking或sleeping)（等待定时唤醒条件）。</p><p>如果大量线程处于此种状态，说明这些线程又去获取第三方资源了，比如第三方的网络资源或读取数据库的操作，长时间无法获得响应，导致大量线程进入等待状态。因此，这说明系统处于一个网络瓶颈或读取数据库操作时间太长。</p><h3 id="系统线程状态为-blocked"><a href="#系统线程状态为-blocked" class="headerlink" title="系统线程状态为 blocked"></a>系统线程状态为 <a href="http://www.javatang.com/archives/2017/10/25/36441958.html#blocked" target="_blank" rel="noopener">blocked</a></h3><p>线程处于阻塞状态，需要根据实际情况进行判断。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>下面通过几个案例进行分解来获得解决问题的方法。</p><h3 id="waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED"><a href="#waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED" class="headerlink" title="waiting for monitor entry 和 java.lang.Thread.State: BLOCKED"></a>waiting for monitor entry 和 java.lang.Thread.State: BLOCKED</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;DB-Processor-13&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-14&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f020]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-3&quot; daemon prio=5 tid=0x00928248 nid=0x8b waiting for monitor entry [0x000000000825d080]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at oracle.jdbc.driver.OracleConnection.isClosed(OracleConnection.java:570)</span><br><span class="line">                - waiting to lock &lt;0xe03ba2e0&gt; (a oracle.jdbc.driver.OracleConnection)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:112)</span><br><span class="line">                - locked &lt;0xe0386580&gt; (a java.util.Vector)</span><br><span class="line">                - locked &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.Cue_1700c.GetNationList(Cue_1700c.java:66)</span><br><span class="line">                at org.apache.jsp.cue_1700c_jsp._jspService(cue_1700c_jsp.java:120)</span><br></pre></td></tr></table></figure><p>上面系统线程的状态是 <code>waiting for monitor entry</code>，说明此线程通过 synchronized(obj) { } 申请进入临界区，但obj对应的 Monitor 被其他线程所拥有，所以 JVM线程的状态是 java.lang.Thread.State: BLOCKED (on object monitor)，说明线程等待资源超时。</p><p>下面的 <code>waiting to lock &lt;0xe0375410&gt;</code> 说明线程在等待给 <code>0xe0375410</code> 这个地址上锁（trying to obtain 0xe0375410 lock），如果在日志中发现有大量的线程都在等待给 <code>0xe0375410</code> 上锁的话，这个时候需要在日志中查找那个线程获取了这个锁 <code>locked &lt;0xe0375410&gt;</code>，如上面的例子中是 “DB-Processor-14” 这个线程，这样就可以顺藤摸瓜了。上面的例子是因为获取数据库操作等待的时间太长所致的，这个时候就需要修改数据库连接的配置信息。</p><p>如果两个线程相互都被对方的线程锁锁住，这样就造成了 <code>死锁</code> 现象，如下面的例子所示：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/常见的Thread Dump日志案例分析/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E5%B8%B8%E8%A7%81%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/1.png"></p><h3 id="waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING"><a href="#waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING" class="headerlink" title="waiting on condition 和 java.lang.Thread.State: TIMED_WAITING"></a>waiting on condition 和 java.lang.Thread.State: TIMED_WAITING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">                at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">                - parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">                at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>JVM线程的状态是 java.lang.Thread.State: TIMED_WAITING (parking)，说明线程处于定时等待的状态，parking指线程处于挂起中。</p><p><code>waiting on condition</code>需要结合堆栈中的 <em>parking to wait for <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack)</0x00000000acd84de8></em> 一起来分析。首先，本线程肯定是在等待某个条件的发生来把自己唤醒。其次，SynchronousQueue并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中的时候必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</p><h3 id="in-Object-wait-和-java-lang-Thread-State-TIMED-WAITING"><a href="#in-Object-wait-和-java-lang-Thread-State-TIMED-WAITING" class="headerlink" title="in Object.wait() 和 java.lang.Thread.State: TIMED_WAITING"></a>in Object.wait() 和 java.lang.Thread.State: TIMED_WAITING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">                at java.lang.Object.wait(Native Method)</span><br><span class="line">                - waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">                - locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>本例中JVM线程的状态是 <code>java.lang.Thread.State: TIMED_WAITING (on object monitor)</code>，说明线程调用了 <code>java.lang.Object.wait(long timeout)</code> 方法而进入了等待状态。</p><p>“Wait Set”中等待的线程状态就是 <code>in Object.wait()</code>，当线程获得了 Monitor进入临界区之后，如果发现线程继续运行的条件没有满足，它就调用对象（通常是被 synchronized 的对象）的wait()方法，放弃了Monitor，进入 “Wait Set” 队列中。只有当别的线程在该对象上调用了 notify()或notifyAll()方法， “Wait Set” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到的运行态。</p><p>另外需要注意的是，是先 <em>locked <0x00000000aa672478></0x00000000aa672478></em> 然后再 <em>waiting on <0x00000000aa672478></0x00000000aa672478></em>，之所以如此，可以通过下面的代码进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span>  <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line"><span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行的过程中，先用 synchronized 获得了这个对象的 Monitor（对应 locked <0x00000000aa672478>），当执行到 <code>lock.wait(timeout);</code> 的时候，线程就放弃了Monitor的所有权，进入 “Wait Set” 队列（对应 waiting on <0x00000000aa672478>）。</0x00000000aa672478></0x00000000aa672478></p><p>前面几篇文章详细说明了如何分析Thread Dump文件，除此之外还可以通过分析JVM堆内存信息来进一步找到问题的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;症状及解决方案&quot;&gt;&lt;a href=&quot;#症状及解决方案&quot; class=&quot;headerlink&quot; title=&quot;症状及解决方案&quot;&gt;&lt;/a&gt;症状及解决方案&lt;/h2&gt;&lt;p&gt;下面列出几种常见的症状即对应的解决方案：&lt;/p&gt;
&lt;h3 id=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;a href=&quot;#CPU占用率很高，响应很慢&quot; class=&quot;headerlink&quot; title=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;/a&gt;CPU占用率很高，响应很慢&lt;/h3&gt;&lt;p&gt;按照&lt;a href=&quot;http://www.javatang.com/archives/2017/10/19/33151873.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》&lt;/a&gt;中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。&lt;br&gt;在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。&lt;a href=&quot;http://www.javatang.com/archives/2017/10/20/12131956.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果线程指向的是”VM Thread”&lt;/a&gt;或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(三)jstat命令的使用及VM Thread分析</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E4%B8%89)jstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AVM%20Thread%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(三)jstat命令的使用及VM Thread分析/</id>
    <published>2019-07-06T12:12:37.013Z</published>
    <updated>2019-07-06T13:17:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="使用jstat命令"><a href="#使用jstat命令" class="headerlink" title="使用jstat命令"></a>使用jstat命令</h2><p>当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 <a href="http://www.javatang.com/archives/2017/10/19/51301886.html#VM_Thread" target="_blank" rel="noopener">VM Thread</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable</span><br></pre></td></tr></table></figure><p>这个时候需要使用 <code>jstat -gc &lt;pid&gt; &lt;period&gt; &lt;times&gt;</code> 命令查看gc的信息，显示结果如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstat命令的使用及VM Thread分析/1.jpg" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AVM%20Thread%E5%88%86%E6%9E%90/1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU      OC         OU       PC        PU       YGC     YGCT    FGC   FGCT       GCT</span><br><span class="line">64.0   64.0   0.0    0.0   332992.0   0.0    666304.0   73192.5   83968.0   83967.9   6893   17.576  6882   2705.923  2723.499</span><br></pre></td></tr></table></figure><a id="more"></a><p>结果中每个项目的含义可以参考官方对jstat的文档，简单翻译如下：</p><ul><li>S0C: Young Generation第一个survivor space的内存大小 (kB).</li><li>S1C: Young Generation第二个survivor space的内存大小 (kB).</li><li>S0U: Young Generation第一个Survivor space当前已使用的内存大小 (kB).</li><li>S1U: Young Generation第二个Survivor space当前已经使用的内存大小 (kB).</li><li>EC: Young Generation中eden space的内存大小 (kB).</li><li>EU: Young Generation中Eden space当前已使用的内存大小 (kB).</li><li>OC: Old Generation的内存大小 (kB).</li><li>OU: Old Generation当前已使用的内存大小 (kB).</li><li>PC: Permanent Generation的内存大小 (kB)</li><li>PU: Permanent Generation当前已使用的内存大小 (kB).</li><li>YGC: 从启动到采样时Young Generation GC的次数</li><li>YGCT: 从启动到采样时Young Generation GC所用的时间 (s).</li><li>FGC: 从启动到采样时Old Generation GC的次数.</li><li>FGCT: 从启动到采样时Old Generation GC所用的时间 (s).</li><li>GCT: 从启动到采样时GC所用的总时间 (s).</li></ul><p>JDK8的结果稍微有所不同，结果含义可以参考：<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a>。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>上面中的Young Generation、Permanent Generation和Old Generation等概念有一些混乱，这里简要的进行说明。简单来说，JVM内存由堆（Heap）和非堆（Non-heap）内存组成，前者共运行在JVM之上的程序使用，后者供JVM自己使用。</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstat命令的使用及VM Thread分析/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AVM%20Thread%E5%88%86%E6%9E%90/2.png"></p><p>堆内存的组成如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstat命令的使用及VM Thread分析/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AVM%20Thread%E5%88%86%E6%9E%90/3.png"></p><p>非堆内存由 Permanent Generation 和 Code Cache 两部分组成：</p><ul><li>Permanent Generation（持久代）: 保存虚拟机自己的静态(refective)数据，主要存放加载的Class类级别静态对象如class本身，method，field等等。permanent generation空间不足会引发full GC；</li><li>Code Cache: 用于编译和保存本地代码（native code）的内存，JVM内部处理或优化。</li></ul><h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><h3 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h3><ul><li>堆内存（总的）由 <code>-Xms</code> 和 <code>-Xmx</code> 分别设置最小和最大堆内存</li><li>New Generation 由 <code>-Xmn</code> 设置，<code>-XX:SurvivorRatio=m</code> 设置 Eden和 两个Survivor区的大小比值；<code>-XX:NewRatio=n</code> 设置 New Generation 和 Old Generation 的大小比值。</li><li>每个线程的堆栈大小由 ·-Xss· 设置，JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li></ul><h3 id="非堆内存设置"><a href="#非堆内存设置" class="headerlink" title="非堆内存设置"></a>非堆内存设置</h3><p>非堆内存由 <code>-XX:PermSize=n</code> 和 <code>-XX:MaxPermSize=n</code> 分别设置最小和最大非堆内存大小</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>介绍完上面的概念之后，我们再来看最上面的日志信息，有两个地方有问题：<br>一是FGC（完全GC）的数量太大了，正常来说FGC应该占整个GC（YGC+FGC）的1%到5%才正常，上面日志上完全GC的次数太多了；二是日志中PU的值太大了，基本上已经达到设置的PC了，因此需要增大MaxPermSize的值。<br>不过这只是权宜之计，出现这么大的非堆内存，肯定什么地方出现了问题，还需要进一步找到占用内存的原因，这也是后面文章所要说的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用jstat命令&quot;&gt;&lt;a href=&quot;#使用jstat命令&quot; class=&quot;headerlink&quot; title=&quot;使用jstat命令&quot;&gt;&lt;/a&gt;使用jstat命令&lt;/h2&gt;&lt;p&gt;当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 &lt;a href=&quot;http://www.javatang.com/archives/2017/10/19/51301886.html#VM_Thread&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VM Thread&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;VM Thread&amp;quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个时候需要使用 &lt;code&gt;jstat -gc &amp;lt;pid&amp;gt; &amp;lt;period&amp;gt; &amp;lt;times&amp;gt;&lt;/code&gt; 命令查看gc的信息，显示结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstat命令的使用及VM Thread分析/1.jpg&quot; alt=&quot;https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AVM%20Thread%E5%88%86%E6%9E%90/1.jpg&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;S0C    S1C    S0U    S1U      EC       EU      OC         OU       PC        PU       YGC     YGCT    FGC   FGCT       GCT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64.0   64.0   0.0    0.0   332992.0   0.0    666304.0   73192.5   83968.0   83967.9   6893   17.576  6882   2705.923  2723.499&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(二)jstack生成的Thread Dump日志结构解析</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E4%BA%8C)jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(二)jstack生成的Thread Dump日志结构解析/</id>
    <published>2019-07-06T09:20:20.416Z</published>
    <updated>2019-07-06T13:18:02.312Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><p>首先对Thread Dump日志文件的结构进行分析。一个典型的thread dump文件主要由一下几个部分组成：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstack生成的Thread Dump日志结构解析/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/1.png"></p><a id="more"></a><p>上图将JVM上的线程堆栈信息和线程信息做了详细的拆解。</p><h2 id="第一部分：Full-thread-dump-identifier"><a href="#第一部分：Full-thread-dump-identifier" class="headerlink" title="第一部分：Full thread dump identifier"></a>第一部分：Full thread dump identifier</h2><p>这一部分是内容最开始的部分，展示了快照文件的生成时间和JVM的版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-10-19 10:46:44</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode):</span><br></pre></td></tr></table></figure><h2 id="第二部分：Java-EE-middleware-third-party-amp-custom-application-Threads"><a href="#第二部分：Java-EE-middleware-third-party-amp-custom-application-Threads" class="headerlink" title="第二部分：Java EE middleware, third party &amp; custom application Threads"></a>第二部分：Java EE middleware, third party &amp; custom application Threads</h2><p>这是整个文件的核心部分，里面展示了JavaEE容器（如tomcat、resin等）、自己的程序中所使用的线程信息。这一部分详细的含义见 <a href="http://www.javatang.com/archives/2017/10/25/36441958.html" target="_blank" rel="noopener">Java内存泄漏分析系列之四：jstack生成的Thread Dump日志线程状态分析</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;resin-22129&quot; daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)</span><br></pre></td></tr></table></figure><h2 id="第三部分：HotSpot-VM-Thread"><a href="#第三部分：HotSpot-VM-Thread" class="headerlink" title="第三部分：HotSpot VM Thread"></a>第三部分：HotSpot VM Thread</h2><p>这一部分展示了JVM内部线程的信息，用于执行内部的原生操作。下面常见的集中内置线程：</p><h3 id="“Attach-Listener”"><a href="#“Attach-Listener”" class="headerlink" title="“Attach Listener”"></a>“Attach Listener”</h3><p>该线程负责接收外部命令，执行该命令并把结果返回给调用者，此种类型的线程通常在桌面程序中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Attach Listener&quot; daemon prio=5 tid=0x00007fc6b6800800 nid=0x3b07 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“DestroyJavaVM”"><a href="#“DestroyJavaVM”" class="headerlink" title="“DestroyJavaVM”"></a>“DestroyJavaVM”</h3><p>执行main()的线程在执行完之后调用JNI中的 jni_DestroyJavaVM() 方法会唤起DestroyJavaVM 线程。在JBoss启动之后，也会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;DestroyJavaVM&quot; prio=5 tid=0x00007fc6b3001000 nid=0x1903 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Service-Thread”"><a href="#“Service-Thread”" class="headerlink" title="“Service Thread”"></a>“Service Thread”</h3><p>用于启动服务的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Service Thread&quot; daemon prio=10 tid=0x00007fbea81b3000 nid=0x5f2 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“CompilerThread”"><a href="#“CompilerThread”" class="headerlink" title="“CompilerThread”"></a>“CompilerThread”</h3><p>用来调用JITing，实时编译装卸CLASS。通常JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，比如CompilerThread1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;C2 CompilerThread1&quot; daemon prio=10 tid=0x00007fbea814b000 nid=0x5f1 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; daemon prio=10 tid=0x00007fbea8142000 nid=0x5f0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Signal-Dispatcher”"><a href="#“Signal-Dispatcher”" class="headerlink" title="“Signal Dispatcher”"></a>“Signal Dispatcher”</h3><p>Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。<br>signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Signal Dispatcher&quot; daemon prio=10 tid=0x00007fbea81bf800 nid=0x5ef runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Finalizer”"><a href="#“Finalizer”" class="headerlink" title="“Finalizer”"></a>“Finalizer”</h3><p>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：<br>（1）只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；<br>（2）该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；<br>（3）JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；<br>（4）JVM为什么要单独用一个线程来执行finalize()方法呢？<br>如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Finalizer&quot; daemon prio=10 tid=0x00007fbea80da000 nid=0x5eb in Object.wait() [0x00007fbeac044000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)</span><br><span class="line">    - locked &lt;0x00000006d173c1a8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)</span><br><span class="line">    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br></pre></td></tr></table></figure><h3 id="“Reference-Handler”"><a href="#“Reference-Handler”" class="headerlink" title="“Reference Handler”"></a>“Reference Handler”</h3><p>JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Reference Handler&quot; daemon prio=10 tid=0x00007fbea80d8000 nid=0x5ea in Object.wait() [0x00007fbeac085000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    at java.lang.Object.wait(Object.java:503)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)</span><br><span class="line">    - locked &lt;0x00000006d173c1f0&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure><h3 id="“VM-Thread”"><a href="#“VM-Thread”" class="headerlink" title="“VM Thread”"></a>“VM Thread”</h3><p>JVM中线程的母体，根据HotSpot源码中关于vmThread.hpp里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单例的VM线程是会被其他线程所使用来做一些VM操作（如清扫垃圾等）。<br>在 VM Thread 的结构体里有一个VMOperationQueue列队，所有的VM线程操作(vm_operation)都会被保存到这个列队当中，VMThread 本身就是一个线程，它的线程负责执行一个自轮询的loop函数(具体可以参考：VMThread.cpp里面的void VMThread::loop()) ，该loop函数从VMOperationQueue列队中按照优先级取出当前需要执行的操作对象(VM_Operation)，并且调用VM_Operation-&gt;evaluate函数去执行该操作类型本身的业务逻辑。<br>VM操作类型被定义在vm_operations.hpp文件内，列举几个：ThreadStop、ThreadDump、PrintThreads、GenCollectFull、GenCollectFullConcurrent、CMS_Initial_Mark、CMS_Final_Remark….. 有兴趣的同学，可以自己去查看源文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable</span><br></pre></td></tr></table></figure><h2 id="第四部分：HotSpot-GC-Thread"><a href="#第四部分：HotSpot-GC-Thread" class="headerlink" title="第四部分：HotSpot GC Thread"></a>第四部分：HotSpot GC Thread</h2><p>JVM中用于进行资源回收的线程，包括以下几种类型的线程：</p><h3 id="“VM-Periodic-Task-Thread”"><a href="#“VM-Periodic-Task-Thread”" class="headerlink" title="“VM Periodic Task Thread”"></a>“VM Periodic Task Thread”</h3><p>该线程是JVM周期性任务调度的线程，它由WatcherThread创建，是一个单例对象。该线程在JVM内使用得比较频繁，比如：定期的内存监控、JVM运行状况监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Periodic Task Thread&quot; prio=10 tid=0x00007fbea82ae800 nid=0x5fa waiting on condition</span><br></pre></td></tr></table></figure><p>可以使用jstat 命令查看GC的情况，比如查看某个进程没有存活必要的引用可以使用命令 <code>jstat -gcutil &lt;pid&gt; 250 7</code> 参数中pid是进程id，后面的250和7表示每250毫秒打印一次，总共打印7次。<br>这对于防止因为应用代码中直接使用native库或者第三方的一些监控工具的内存泄漏有非常大的帮助。</p><h3 id="“GC-task-thread-0-ParallelGC-”"><a href="#“GC-task-thread-0-ParallelGC-”" class="headerlink" title="“GC task thread#0 (ParallelGC)”"></a>“GC task thread#0 (ParallelGC)”</h3><p>垃圾回收线程，该线程会负责进行垃圾回收。通常JVM会启动多个线程来处理这个工作，线程名称中#后面的数字也会累加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; prio=5 tid=0x00007fc6b480d000 nid=0x2503 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2812000 nid=0x2703 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2812800 nid=0x2903 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2813000 nid=0x2b03 runnable</span><br></pre></td></tr></table></figure><p> 如果在JVM中增加了 <code>-XX:+UseConcMarkSweepGC</code> 参数将会启用CMS （Concurrent Mark-Sweep）GC Thread方式，以下是该模式下的线程类型：</p><h3 id="“Gang-worker-0-Parallel-GC-Threads-”"><a href="#“Gang-worker-0-Parallel-GC-Threads-”" class="headerlink" title="“Gang worker#0 (Parallel GC Threads)”"></a>“Gang worker#0 (Parallel GC Threads)”</h3><p>原来垃圾回收线程GC task thread#0 (ParallelGC) 被替换为 Gang worker#0 (Parallel GC Threads)。Gang worker 是JVM用于年轻代垃圾回收(minor gc)的线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Gang worker#0 (Parallel GC Threads)&quot; prio=10 tid=0x00007fbea801b800 nid=0x5e4 runnable </span><br><span class="line"></span><br><span class="line">&quot;Gang worker#1 (Parallel GC Threads)&quot; prio=10 tid=0x00007fbea801d800 nid=0x5e7 runnable</span><br></pre></td></tr></table></figure><h3 id="“Concurrent-Mark-Sweep-GC-Thread”"><a href="#“Concurrent-Mark-Sweep-GC-Thread”" class="headerlink" title="“Concurrent Mark-Sweep GC Thread”"></a>“Concurrent Mark-Sweep GC Thread”</h3><p>并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于年老代垃圾回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Concurrent Mark-Sweep GC Thread&quot; prio=10 tid=0x00007fbea8073800 nid=0x5e8 runnable</span><br></pre></td></tr></table></figure><h3 id="“Surrogate-Locker-Thread-Concurrent-GC-”"><a href="#“Surrogate-Locker-Thread-Concurrent-GC-”" class="headerlink" title="“Surrogate Locker Thread (Concurrent GC)”"></a>“Surrogate Locker Thread (Concurrent GC)”</h3><p>此线程主要配合CMS垃圾回收器来使用，是一个守护线程，主要负责处理GC过程中Java层的Reference（指软引用、弱引用等等）与jvm 内部层面的对象状态同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Surrogate Locker Thread (Concurrent GC)&quot; daemon prio=10 tid=0x00007fbea8158800 nid=0x5ee waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><p>这里以 WeakHashMap 为例进行说明，首先是一个关键点：</p><ul><li>WeakHashMap和HashMap一样，内部有一个Entry[]数组;</li><li>WeakHashMap的Entry比较特殊，它的继承体系结构为Entry-&gt;WeakReference-&gt;Reference;</li><li>Reference 里面有一个全局锁对象：Lock，它也被称为pending_lock，注意：它是静态对象；</li><li>Reference 里面有一个静态变量：pending；</li><li>Reference 里面有一个静态内部类：ReferenceHandler的线程，它在static块里面被初始化并且启动，启动完成后处于wait状态，它在一个Lock同步锁模块中等待；</li><li>WeakHashMap里面还实例化了一个ReferenceQueue列队</li></ul><p>假设，WeakHashMap对象里面已经保存了很多对象的引用，JVM 在进行CMS GC的时候会创建一个ConcurrentMarkSweepThread（简称CMST）线程去进行GC。ConcurrentMarkSweepThread线程被创建的同时会创建一个SurrogateLockerThread（简称SLT）线程并且启动它，SLT启动之后，处于等待阶段。<br>CMST开始GC时，会发一个消息给SLT让它去获取Java层Reference对象的全局锁：Lock。直到CMS GC完毕之后，JVM 会将WeakHashMap中所有被回收的对象所属的WeakReference容器对象放入到Reference 的pending属性当中（每次GC完毕之后，pending属性基本上都不会为null了），然后通知SLT释放并且notify全局锁:Lock。此时激活了ReferenceHandler线程的run方法，使其脱离wait状态，开始工作了。<br>ReferenceHandler这个线程会将pending中的所有WeakReference对象都移动到它们各自的列队当中，比如当前这个WeakReference属于某个WeakHashMap对象，那么它就会被放入相应的ReferenceQueue列队里面（该列队是链表结构）。 当我们下次从WeakHashMap对象里面get、put数据或者调用size方法的时候，WeakHashMap就会将ReferenceQueue列队中的WeakReference依依poll出来去和Entry[]数据做比较，如果发现相同的，则说明这个Entry所保存的对象已经被GC掉了，那么将Entry[]内的Entry对象剔除掉。</p><h2 id="第五部分：JNI-global-references-count"><a href="#第五部分：JNI-global-references-count" class="headerlink" title="第五部分：JNI global references count"></a>第五部分：JNI global references count</h2><p>这一部分主要回收那些在native代码上被引用，但在java代码中却没有存活必要的引用，对于防止因为应用代码中直接使用native库或第三方的一些监控工具的内存泄漏有非常大的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI global references: 830</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先对Thread Dump日志文件的结构进行分析。一个典型的thread dump文件主要由一下几个部分组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/jstack生成的Thread Dump日志结构解析/1.png&quot; alt=&quot;https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/1.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(一)使用jstack定位线程堆栈信息</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E4%B8%80)%E4%BD%BF%E7%94%A8jstack%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(一)使用jstack定位线程堆栈信息/</id>
    <published>2019-07-06T09:15:38.041Z</published>
    <updated>2019-07-06T13:17:33.688Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在对Java内存泄漏进行分析的时候，需要对jvm运行期间的内存占用、线程执行等情况进行记录的dump文件，常用的主要有thread dump和heap dump。</p><ul><li><strong>thread dump</strong> 主要记录JVM在某一时刻各个线程执行的情况，以栈的形式显示，是一个文本文件。通过对thread dump文件可以分析出程序的问题出现在什么地方，从而定位具体的代码然后进行修正。thread dump需要结合占用系统资源的线程id进行分析才有意义。</li><li><strong>heap dump</strong> 主要记录了在某一时刻JVM堆中对象使用的情况，即某个时刻JVM堆的快照，是一个二进制文件，主要用于分析哪些对象占用了太对的堆空间，从而发现导致内存泄漏的对象。</li></ul><p>上面两种dump文件都具有实时性，因此需要在服务器出现问题的时候生成，并且多生成几个文件，方便进行对比分析。下面我们先来说一下如何生成 thread dump。</p><a id="more"></a><h2 id="使用jstack生成thread-dump"><a href="#使用jstack生成thread-dump" class="headerlink" title="使用jstack生成thread dump"></a>使用<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html" target="_blank" rel="noopener">jstack</a>生成thread dump</h2><p>当服务器出现高CPU的时候，首先执行 <code>top -c</code> 命令动态显示进程及占用资源的排行，如下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用jstack定位线程堆栈信息/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8jstack%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/1.png"></p><p>top后面的参数<code>-c</code>可以显示进程详细的信息。<code>top</code>命令执行的时候还可以执行一些快捷键：</p><ul><li><code>1</code> 对于多核服务器，可以显示各个CPU占用资源的情况</li><li><code>shift+h</code> 显示所有的线程信息</li><li><code>shift+w</code> 将当前 <code>top</code> 命令的设置保存到 <code>~/.toprc</code> 文件中，这样不用每次都执行快捷键了</li></ul><p>以上图为例，pid为1503的进程占用了大量的CPU资源，接下来需要将占用CPU最高进程中的线程打印出来，可以用 <code>top -bn1 -H -p &lt;pid&gt;</code> 命令，执行结果如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用jstack定位线程堆栈信息/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8jstack%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/2.png"></p><p>上面 <code>-bn1</code> 参数的含义是只输出一次结果，而不是显示一个动态的结果。</p><p>我个人请喜欢用 <code>ps -mp &lt;pid&gt; -o THREAD,tid,time | sort -k2r</code> 命令查看，后面的sort参数根据线程占用的cpu比例进行排序，结果如下：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用jstack定位线程堆栈信息/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8jstack%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/3.png"></p><p>接下来我们清楚今天的主角 <code>jstack</code>，这是一个在JDK5开始提供的内置工具，可以打印指定进程中线程运行的状态，包括线程数量、是否存在死锁、资源竞争情况和线程的状态等等。有下面的几个常用的参数：</p><ul><li><code>-l</code> 长列表，打印关于锁的附加信息</li><li><code>-m</code> 打印java和jni框架的所有栈信息</li></ul><p>因为thread id在栈信息中是以十六进制的形式显示的，因此需要使用 <code>printf &quot;%x \n&quot; &lt;tid&gt;</code> 命令将现场id转成十六进制的值，然后执行 <code>jstack -l &lt;pid&gt; | grep &lt;thread-hex-id&gt; -A 10</code> 命令显示出错的堆栈信息，如下图：</p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/JVM故障分析系列/使用jstack定位线程堆栈信息/4.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/%E4%BD%BF%E7%94%A8jstack%E5%AE%9A%E4%BD%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/4.png"></p><p>上面命令中 <code>-A 10</code> 参数用来指定显示行数，否则只会显示一行信息。</p><p>这样通过上图，可以很快地定位到程序问题的代码，然后对代码进行分析和改进即可。<strong>注意：需要在多个时间段提出多个 Thread Dump信息，然后综合进行对比分析，单独分析一个文件是没有意义的。</strong></p><h2 id="生成shell文件"><a href="#生成shell文件" class="headerlink" title="生成shell文件"></a>生成shell文件</h2><p>上面讲述了整个的分析过程，不过所有的命令就是实时的，所以最好创建一个shell脚本瞬间执行完成，下面对 <a href="http://www.jianshu.com/p/90579ec3113f" target="_blank" rel="noopener">当CPU飙高时，它在做什么</a> 这篇文章中所提供的shell进行了改进如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ $# -le 0 ]; then</span><br><span class="line">    echo "usage: $0 &lt;pid&gt; [line-number]"</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> java home</span></span><br><span class="line">if test -z $JAVA_HOME </span><br><span class="line">then</span><br><span class="line">    JAVA_HOME='/usr/local/jdk'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">pid</span></span><br><span class="line">pid=$1</span><br><span class="line"><span class="meta">#</span><span class="bash"> checking pid</span></span><br><span class="line">if test -z "$($JAVA_HOME/bin/jps -l | cut -d '' -f 1 | grep $pid)"</span><br><span class="line">then</span><br><span class="line">    echo "process of $pid is not exists"</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">line number</span></span><br><span class="line">linenum=$2</span><br><span class="line">if test -z $linenum</span><br><span class="line">then</span><br><span class="line">    linenum=10</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">stackfile=stack$pid.dump</span><br><span class="line">threadsfile=threads$pid.dump</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> generate java stack</span></span><br><span class="line"><span class="meta">$</span><span class="bash">JAVA_HOME/bin/jstack -l <span class="variable">$pid</span> &gt;&gt; <span class="variable">$stackfile</span></span></span><br><span class="line">ps -mp $pid -o THREAD,tid,time | sort -k2r | awk '&#123;if ($1 !="USER" &amp;&amp; $2 != "0.0" &amp;&amp; $8 !="-") print $8;&#125;' | xargs printf "%x\n" &gt;&gt; $threadsfile</span><br><span class="line">tids="$(cat $threadsfile)"</span><br><span class="line">for tid in $tids</span><br><span class="line">do</span><br><span class="line">    echo "------------------------------ ThreadId ($tid) ------------------------------"</span><br><span class="line">    cat $stackfile | grep 0x$tid -A $linenum</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">rm -f $stackfile $threadsfile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;在对Java内存泄漏进行分析的时候，需要对jvm运行期间的内存占用、线程执行等情况进行记录的dump文件，常用的主要有thread dump和heap dump。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;thread dump&lt;/strong&gt; 主要记录JVM在某一时刻各个线程执行的情况，以栈的形式显示，是一个文本文件。通过对thread dump文件可以分析出程序的问题出现在什么地方，从而定位具体的代码然后进行修正。thread dump需要结合占用系统资源的线程id进行分析才有意义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap dump&lt;/strong&gt; 主要记录了在某一时刻JVM堆中对象使用的情况，即某个时刻JVM堆的快照，是一个二进制文件，主要用于分析哪些对象占用了太对的堆空间，从而发现导致内存泄漏的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两种dump文件都具有实时性，因此需要在服务器出现问题的时候生成，并且多生成几个文件，方便进行对比分析。下面我们先来说一下如何生成 thread dump。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>(四)jstack生成的Thread Dump日志线程状态</title>
    <link href="http://yoursite.com/2019/07/06/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/(%E5%9B%9B)jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%20/"/>
    <id>http://yoursite.com/2019/07/06/JVM故障分析/(四)jstack生成的Thread Dump日志线程状态 /</id>
    <published>2019-07-06T09:07:24.670Z</published>
    <updated>2019-07-06T12:07:47.921Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.javatang.com" target="_blank" rel="noopener">http://www.javatang.com</a></p><h2 id="Thread-Dump日志的线程信息"><a href="#Thread-Dump日志的线程信息" class="headerlink" title="Thread Dump日志的线程信息"></a>Thread Dump日志的线程信息</h2><p>以下面的日志为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"resin-22129"</span> daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)<span class="string">"Timer-20"</span> daemon prio=10 tid=0x00007fe3a4bfb800 nid=0x1a31 <span class="keyword">in</span> Object.wait() [0x00007fe3a077a000]   java.lang.Thread.State: TIMED_WAITING (on object monitor)    at java.lang.Object.wait(Native Method)    - waiting on &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)    at java.util.TimerThread.mainLoop(Timer.java:552)    - locked &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)    at java.util.TimerThread.run(Timer.java:505)</span><br></pre></td></tr></table></figure><p>以上依次是：</p><a id="more"></a><ul><li><code>&quot;resin-22129&quot;</code><strong>线程名称：</strong>如果使用 java.lang.Thread 类生成一个线程的时候，线程名称为 Thread-(数字) 的形式，这里是resin生成的线程；</li><li><code>daemon</code><strong>线程类型：</strong>线程分为守护线程 (daemon) 和非守护线程 (non-daemon) 两种，通常都是守护线程；</li><li><code>prio=10</code><strong>线程优先级：</strong>默认为5，数字越大优先级越高；</li><li><code>tid=0x00007fbe5c34e000</code><strong>JVM线程的id：</strong>JVM内部线程的唯一标识，通过 java.lang.Thread.getId()获取，通常用自增的方式实现；</li><li><code>nid=0x4cb1</code><strong>系统线程id：</strong>对应的系统线程id（Native Thread ID)，可以通过 top 命令进行查看，现场id是十六进制的形式；</li><li><code>waiting on condition</code><strong>系统线程状态：</strong>这里是系统的线程状态，具体的含义见下面 <code>系统线程状态</code> 部分；</li><li><code>[0x00007fbe4ff7c000]</code><strong>起始栈地址：</strong>线程堆栈调用的其实内存地址；</li><li><code>java.lang.Thread.State: WAITING (parking)</code><strong>JVM线程状态：</strong>这里标明了线程在代码级别的状态，详细的内容见下面的 JVM线程运行状态 部分。</li><li><strong>线程调用栈信息：</strong>下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。</li></ul><h2 id="系统线程状态-Native-Thread-Status"><a href="#系统线程状态-Native-Thread-Status" class="headerlink" title="系统线程状态 (Native Thread Status)"></a>系统线程状态 (Native Thread Status)</h2><p>系统线程有如下状态：</p><ul><li><p>deadlock：死锁线程，一般指多个线程调用期间进入了相互资源占用，导致一直等待无法释放的情况。</p></li><li><p>runnable：一般指该线程正在执行状态中，该线程占用了资源，正在处理某个操作，如通过SQL语句查询数据库、对某个文件进行写入等。</p></li><li><p>blocked：线程正处于阻塞状态，指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。</p></li><li><p>waiting on condition：线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。</p><ol><li><p>如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某种资源且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，或者正在等待其他线程的执行等。</p></li><li><p>如果发现有大量的线程都正处于这种状态，并且堆栈信息中得知正等待网络读写，这是因为网络阻塞导致线程无法执行，很有可能是一个网络瓶颈的征兆：</p><ul><li>网络非常繁忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；</li><li>网络可能是空闲的，但由于路由或防火墙等原因，导致包无法正常到达；</li></ul><p>所以一定要结合系统的一些性能观察工具进行综合分析，比如netstat统计单位时间的发送包的数量，看是否很明显超过了所在网络带宽的限制；观察CPU的利用率，看系统态的CPU时间是否明显大于用户态的CPU时间。这些都指向由于网络带宽所限导致的网络瓶颈。</p></li><li><p>还有一种常见的情况是该线程在 sleep，等待 sleep 的时间到了，将被唤醒。</p></li></ol></li><li><p>waiting for monitor entry 或 in Object.wait()：Moniter 是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者class的锁，每个对象都有，也仅有一个 Monitor。 </p><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/1.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1.png"></p><p>从上图可以看出，每个Monitor在某个时刻只能被一个线程拥有，该线程就是 “Active Thread”，而其他线程都是 “Waiting Thread”，分别在两个队列 “Entry Set”和”Waint Set”里面等待。其中在 “Entry Set” 中等待的线程状态是 waiting for monitor entry，在 “Wait Set” 中等待的线程状态是 in Object.wait()。</p><ol><li><p>“Entry Set”里面的线程。</p><p>我们称被 synchronized 保护起来的代码段为临界区，对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>当一个线程申请进入临界区时，它就进入了 “Entry Set” 队列中，这时候有两种可能性：</p><ul><li>该Monitor不被其他线程拥有，”Entry Set”里面也没有其他等待的线程。本线程即成为相应类或者对象的Monitor的Owner，执行临界区里面的代码；此时在Thread Dump中显示线程处于 “Runnable” 状态。</li><li>该Monitor被其他线程拥有，本线程在 “Entry Set” 队列中等待。此时在Thread Dump中显示线程处于 “waiting for monity entry” 状态。</li></ul><p>临界区的设置是为了保证其内部的代码执行的原子性和完整性，但因为临界区在任何时间只允许线程串行通过，这和我们使用多线程的初衷是相反的。如果在多线程程序中大量使用synchronized，或者不适当的使用它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在Thread Dump中发现这个情况，应该审视源码并对其进行改进。</p></li><li><p>“Wait Set”里面的线程</p><p>当线程获得了Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（通常是被synchronized的对象）的wait()方法，放弃Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify()或者notifyAll()方法，”Wait Set”队列中的线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。”Wait Set”中的线程在Thread Dump中显示的状态为 in Object.wait()。通常来说，</p><p>通常来说，当CPU很忙的时候关注 Runnable 状态的线程，反之则关注 waiting for monitor entry 状态的线程。</p></li></ol></li></ul><h2 id="JVM线程运行状态-JVM-Thread-Status"><a href="#JVM线程运行状态-JVM-Thread-Status" class="headerlink" title="JVM线程运行状态 (JVM Thread Status)"></a>JVM线程运行状态 (JVM Thread Status)</h2><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/2.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack生成的Thread%20Dump日志线程状态/2.png"></p><p>在 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">java.lang.Thread.State</a> 中定义了线程的状态：</p><ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#NEW" target="_blank" rel="noopener">NEW</a>：至今尚未启动的线程的状态。线程刚被创建，但尚未启动。</li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#RUNNABLE" target="_blank" rel="noopener">RUNNABLE</a>：可运行线程的线程状态。线程正在JVM中执行，有可能在等待操作系统中的其他资源，比如处理器。</li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#BLOCKED" target="_blank" rel="noopener">BLOCKED</a>：受阻塞并且正在等待监视器的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在调用 Object.wait 之后再次进入同步的块/方法。在Thread Dump日志中通常显示为 <em>java.lang.Thread.State: BLOCKED (on object monitor)</em> 。  </li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#WAITING" target="_blank" rel="noopener">WAITING</a>：某一等待线程的线程状态。线程正在无期限地等待另一个线程来执行某一个特定的操作，线程因为调用下面的方法之一而处于等待状态：<ul><li>不带超时的 Object.wait 方法，日志中显示为 <em>java.lang.Thread.State: WAITING (on object monitor)</em></li><li>不带超时的 Thread.join 方法</li><li>LockSupport.park 方法，日志中显示为 <em>java.lang.Thread.State: WAITING (parking)</em></li></ul></li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#TIMED_WAITING" target="_blank" rel="noopener">TIMED_WAITING</a>：指定了等待时间的某一等待线程的线程状态。线程正在等待另一个线程来执行某一个特定的操作，并设定了指定等待的时间，线程因为调用下面的方法之一而处于定时等待状态：<ul><li>Thread.sleep 方法</li><li>指定超时值的 Object.wait 方法</li><li>指定超时值的 Thread.join 方法</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html#TERMINATED" target="_blank" rel="noopener">TERMINATED</a>：线程处于终止状态。根据Java Doc中的说明，在给定的时间上，一个只能处于上述的一种状态之中，并且这些状态都是JVM的状态，跟操作系统中的线程状态无关。</li></ul><h2 id="线程状态样例"><a href="#线程状态样例" class="headerlink" title="线程状态样例"></a>线程状态样例</h2><h3 id="等待状态样例"><a href="#等待状态样例" class="headerlink" title="等待状态样例"></a>等待状态样例</h3><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/3.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/3.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"IoWaitThread"</span> prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]   java.lang.Thread.State: WAITING (parking)                at sun.misc.Unsafe.park(Native Method)                - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000007d5c45850&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)                at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)                at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:1987)                at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)                at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)                at com.nbp.theplatform.threaddump.ThreadIoWaitState<span class="variable">$IoWaitHandler2</span>.run(ThreadIoWaitState.java:89)                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上面例子中，IoWaitThread 线程保持等待状态并从 LinkedBlockingQueue 接收消息，如果 LinkedBlockingQueue 一直没有消息，该线程的状态将不会改变。</p><h3 id="阻塞状态样例"><a href="#阻塞状态样例" class="headerlink" title="阻塞状态样例"></a>阻塞状态样例</h3><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/4.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/4.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"BLOCKED_TEST pool-1-thread-1"</span> prio=6 tid=0x0000000006904800 nid=0x28f4 runnable [0x000000000785f000]   java.lang.Thread.State: RUNNABLE                at java.io.FileOutputStream.writeBytes(Native Method)                at java.io.FileOutputStream.write(FileOutputStream.java:282)                at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)                at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)                - locked &lt;0x0000000780a31778&gt; (a java.io.BufferedOutputStream)                at java.io.PrintStream.write(PrintStream.java:432)                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)                at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:202)                at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:272)                at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:85)                - locked &lt;0x0000000780a040c0&gt; (a java.io.OutputStreamWriter)                at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:168)                at java.io.PrintStream.newLine(PrintStream.java:496)                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)                at java.io.PrintStream.println(PrintStream.java:687)                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:44)                - locked &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)                at com.nbp.theplatform.threaddump.ThreadBlockedState<span class="variable">$1</span>.run(ThreadBlockedState.java:7)                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:886)                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:908)                at java.lang.Thread.run(Thread.java:662)   Locked ownable synchronizers:                - &lt;0x0000000780a31758&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)<span class="string">"BLOCKED_TEST pool-1-thread-2"</span> prio=6 tid=0x0000000007673800 nid=0x260c waiting <span class="keyword">for</span> monitor entry [0x0000000008abf000]   java.lang.Thread.State: BLOCKED (on object monitor)                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)                at com.nbp.theplatform.threaddump.ThreadBlockedState<span class="variable">$2</span>.run(ThreadBlockedState.java:26)                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:886)                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:908)                at java.lang.Thread.run(Thread.java:662)   Locked ownable synchronizers:                - &lt;0x0000000780b0c6a0&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)<span class="string">"BLOCKED_TEST pool-1-thread-3"</span> prio=6 tid=0x00000000074f5800 nid=0x1994 waiting <span class="keyword">for</span> monitor entry [0x0000000008bbf000]   java.lang.Thread.State: BLOCKED (on object monitor)                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)                at com.nbp.theplatform.threaddump.ThreadBlockedState<span class="variable">$3</span>.run(ThreadBlockedState.java:34)                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:886                at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:908)                at java.lang.Thread.run(Thread.java:662)   Locked ownable synchronizers:                - &lt;0x0000000780b0e1b8&gt; (a java.util.concurrent.locks.ReentrantLock<span class="variable">$NonfairSync</span>)</span><br></pre></td></tr></table></figure><p>在上面的例子中，BLOCKED_TEST pool-1-thread-1 线程占用了 <0x0000000780a000b0> 锁，然而 BLOCKED_TEST pool-1-thread-2 和 BLOCKED_TEST pool-1-thread-3 threads 正在等待获取锁。</0x0000000780a000b0></p><h3 id="死锁状态样例"><a href="#死锁状态样例" class="headerlink" title="死锁状态样例"></a>死锁状态样例</h3><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/5.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/5.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"DEADLOCK_TEST-1"</span> daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting <span class="keyword">for</span> monitor entry [0x000000000805f000]   java.lang.Thread.State: BLOCKED (on object monitor)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.goMonitorDeadlock(ThreadDeadLockState.java:197)                - waiting to lock &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.monitorOurLock(ThreadDeadLockState.java:182)                - locked &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.run(ThreadDeadLockState.java:135)   Locked ownable synchronizers:                - None<span class="string">"DEADLOCK_TEST-2"</span> daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting <span class="keyword">for</span> monitor entry [0x000000000815f000]   java.lang.Thread.State: BLOCKED (on object monitor)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.goMonitorDeadlock(ThreadDeadLockState.java:197)                - waiting to lock &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.monitorOurLock(ThreadDeadLockState.java:182)                - locked &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.run(ThreadDeadLockState.java:135)   Locked ownable synchronizers:                - None<span class="string">"DEADLOCK_TEST-3"</span> daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting <span class="keyword">for</span> monitor entry [0x000000000825f000]   java.lang.Thread.State: BLOCKED (on object monitor)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.goMonitorDeadlock(ThreadDeadLockState.java:197)                - waiting to lock &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.monitorOurLock(ThreadDeadLockState.java:182)                - locked &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$Monitor</span>)                at com.nbp.theplatform.threaddump.ThreadDeadLockState<span class="variable">$DeadlockThread</span>.run(ThreadDeadLockState.java:135)   Locked ownable synchronizers:                - None</span><br></pre></td></tr></table></figure><p>上面的例子中，当线程 A 需要获取线程 B 的锁来继续它的任务，然而线程 B 也需要获取线程 A 的锁来继续它的任务的时候发生的。在 thread dump 中，你能看到 DEADLOCK_TEST-1 线程持有 0x00000007d58f5e48 锁，并且尝试获取 0x00000007d58f5e60 锁。你也能看到 DEADLOCK_TEST-2 线程持有 0x00000007d58f5e60，并且尝试获取 0x00000007d58f5e78，同时 DEADLOCK_TEST-3 线程持有 0x00000007d58f5e78，并且在尝试获取 0x00000007d58f5e48 锁，如你所见，每个线程都在等待获取另外一个线程的锁，这状态将不会被改变直到一个线程丢弃了它的锁。</p><h3 id="无限等待的Runnable状态样例"><a href="#无限等待的Runnable状态样例" class="headerlink" title="无限等待的Runnable状态样例"></a>无限等待的Runnable状态样例</h3><p><img src="https://github.com/mygithubspace/Image-Repository/raw/master/devNote/jstack生成的Thread Dump日志线程状态/6.png" alt="https://github.com/mygithubspace/Image-Repository/blob/master/devNote/jstack%E7%94%9F%E6%88%90%E7%9A%84Thread%20Dump%E6%97%A5%E5%BF%97%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/6.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"socketReadThread"</span> prio=6 tid=0x0000000006a0d800 nid=0x1b40 runnable [0x00000000089ef000]   java.lang.Thread.State: RUNNABLE                at java.net.SocketInputStream.socketRead0(Native Method)                at java.net.SocketInputStream.read(SocketInputStream.java:129)                at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)                at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)                at sun.nio.cs.StreamDecoder.read0(StreamDecoder.java:107)                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:93)                at java.io.InputStreamReader.read(InputStreamReader.java:151)                at com.nbp.theplatform.threaddump.ThreadSocketReadState<span class="variable">$1</span>.run(ThreadSocketReadState.java:27)                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上例中线程的状态是RUNNABLE，但在下面的堆栈日志中发现socketReadThread 线程正在无限等待读取 socket，因此不能单纯通过线程的状态来确定线程是否处于阻塞状态，应该根据详细的堆栈信息进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.javatang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.javatang.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Thread-Dump日志的线程信息&quot;&gt;&lt;a href=&quot;#Thread-Dump日志的线程信息&quot; class=&quot;headerlink&quot; title=&quot;Thread Dump日志的线程信息&quot;&gt;&lt;/a&gt;Thread Dump日志的线程信息&lt;/h2&gt;&lt;p&gt;以下面的日志为例：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;resin-22129&quot;&lt;/span&gt; daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)&lt;span class=&quot;string&quot;&gt;&quot;Timer-20&quot;&lt;/span&gt; daemon prio=10 tid=0x00007fe3a4bfb800 nid=0x1a31 &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Object.wait() [0x00007fe3a077a000]   java.lang.Thread.State: TIMED_WAITING (on object monitor)    at java.lang.Object.wait(Native Method)    - waiting on &amp;lt;0x00000006f0620ff0&amp;gt; (a java.util.TaskQueue)    at java.util.TimerThread.mainLoop(Timer.java:552)    - locked &amp;lt;0x00000006f0620ff0&amp;gt; (a java.util.TaskQueue)    at java.util.TimerThread.run(Timer.java:505)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上依次是：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM故障分析" scheme="http://yoursite.com/categories/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JVM故障分析" scheme="http://yoursite.com/tags/JVM%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
      <category term="jstack" scheme="http://yoursite.com/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Stream Kafka 异常</title>
    <link href="http://yoursite.com/2019/07/04/Exception/Spring%20Cloud%20Stream%20Kafka%20%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/07/04/Exception/Spring Cloud Stream Kafka 异常/</id>
    <published>2019-07-04T02:08:34.184Z</published>
    <updated>2019-07-04T02:51:10.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述-一"><a href="#问题描述-一" class="headerlink" title="问题描述(一)"></a>问题描述(一)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-07-04 10:12:33.287 ERROR 91464 --- [p-nio-80-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] <span class="keyword">in</span> context with path [] threw exception [Request processing failed; nested exception is org.springframework.messaging.MessageHandlingException: error occurred <span class="keyword">in</span> message handler [org.springframework.cloud.stream.binder.kafka.KafkaMessageChannelBinder<span class="variable">$ProducerConfigurationMessageHandler</span>@7cc5f891]; nested exception is org.apache.kafka.common.errors.SerializationException: Can<span class="string">'t convert value of class [B to class org.apache.kafka.common.serialization.StringSerializer specified in value.serializer, failedMessage=GenericMessage [payload=byte[11], headers=&#123;contentType=application/json, id=5279bb8b-7a15-6089-79f6-4a655c430ce8, timestamp=1562206353207&#125;]] with root cause</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">java.lang.ClassCastException: [B cannot be cast to java.lang.String</span></span><br><span class="line"><span class="string">at org.apache.kafka.common.serialization.StringSerializer.serialize(StringSerializer.java:28) ~[kafka-clients-2.0.1.jar:na]</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在Spring Boot配置文件中新增配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.stream.bindings.output.producer.use-native-encoding=true</span><br></pre></td></tr></table></figure><h2 id="问题描述-二"><a href="#问题描述-二" class="headerlink" title="问题描述(二)"></a>问题描述(二)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Failed to start bean <span class="string">'outputBindingLifecycle'</span>; nested exception is java.lang.IllegalArgumentException: A default binder has been requested, but there is no binder available</span><br><span class="line">at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:185) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.context.support.DefaultLifecycleProcessor.access<span class="variable">$200</span>(DefaultLifecycleProcessor.java:53) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.context.support.DefaultLifecycleProcessor<span class="variable">$LifecycleGroup</span>.start(DefaultLifecycleProcessor.java:360) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:158) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:122) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:893) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:161) ~[spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:552) ~[spring-context-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) [spring-boot-2.1.6.RELEASE.jar:2.1.6.RELEASE]</span><br><span class="line">at club.codeopen.kafka.SpringCloudStreanKafkaDemoApplication.main(SpringCloudStreanKafkaDemoApplication.java:10) [classes/:na]</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: A default binder has been requested, but there is no binder available</span><br><span class="line">at org.springframework.util.Assert.notEmpty(Assert.java:508) ~[spring-core-5.1.8.RELEASE.jar:5.1.8.RELEASE]</span><br><span class="line">at org.springframework.cloud.stream.binder.DefaultBinderFactory.doGetBinder(DefaultBinderFactory.java:140) ~[spring-cloud-stream-2.1.2.RELEASE.jar:2.1.2.RELEASE]</span><br><span class="line">at org.springframework.cloud.stream.binder.DefaultBinderFactory.getBinder(DefaultBinderFactory.java:130) ~[spring-cloud-stream-2.1.2.RELEASE.jar:2.1.2.RELEASE]</span><br><span class="line">at org.springframework.cloud.stream.binding.BindingService.getBinder(BindingService.java:337) ~[spring-cloud-stream-2.1.2.RELEASE.jar:2.1.2.RELEASE]</span><br><span class="line">at org.springframework.clou</span><br></pre></td></tr></table></figure><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>检查是否引入依赖<code>spring-cloud-stream-binder-kafka</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>检查是否引入Spring Cloud版本，若未引入，则需要增加依赖的版本信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="问题描述-三"><a href="#问题描述-三" class="headerlink" title="问题描述(三)"></a>问题描述(三)</h2><p>Spring Cloud Stream Kafka 启动成功，发送消息成功，但消费者无法接受 </p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>在Spring Boot配置文件中新增配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.stream.bindings.output.content-type=text/plain</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述-一&quot;&gt;&lt;a href=&quot;#问题描述-一&quot; class=&quot;headerlink&quot; title=&quot;问题描述(一)&quot;&gt;&lt;/a&gt;问题描述(一)&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2019-07-04 10:12:33.287 ERROR 91464 --- [p-nio-80-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; servlet [dispatcherServlet] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; context with path [] threw exception [Request processing failed; nested exception is org.springframework.messaging.MessageHandlingException: error occurred &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; message handler [org.springframework.cloud.stream.binder.kafka.KafkaMessageChannelBinder&lt;span class=&quot;variable&quot;&gt;$ProducerConfigurationMessageHandler&lt;/span&gt;@7cc5f891]; nested exception is org.apache.kafka.common.errors.SerializationException: Can&lt;span class=&quot;string&quot;&gt;&#39;t convert value of class [B to class org.apache.kafka.common.serialization.StringSerializer specified in value.serializer, failedMessage=GenericMessage [payload=byte[11], headers=&amp;#123;contentType=application/json, id=5279bb8b-7a15-6089-79f6-4a655c430ce8, timestamp=1562206353207&amp;#125;]] with root cause&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;java.lang.ClassCastException: [B cannot be cast to java.lang.String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;	at org.apache.kafka.common.serialization.StringSerializer.serialize(StringSerializer.java:28) ~[kafka-clients-2.0.1.jar:na]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;	......&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Exception" scheme="http://yoursite.com/categories/Exception/"/>
    
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Kafka集群搭建</title>
    <link href="http://yoursite.com/2019/06/30/Linux/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/06/30/Linux/Kafka集群搭建/</id>
    <published>2019-06-30T03:34:43.892Z</published>
    <updated>2019-07-06T13:32:16.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Kafka是一款分布式消息发布和订阅系统，具有高性能、高吞吐量的特点而被广泛应用与大数据传输场景。它由LinkedIn公司开发，使用Scala语言编写，之后成为Apache基金会的一个顶级项目。<a href="http://kafka.apache.org/" target="_blank" rel="noopener">官方网站</a></p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="下载并解压Kafka包"><a href="#下载并解压Kafka包" class="headerlink" title="下载并解压Kafka包"></a>下载并解压Kafka包</h3><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">官方下载地址</a></p><blockquote><p>注意Kafka所基于的Scala版本</p><ul><li>Binary downloads:<ul><li>Scala 2.11  - <a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz" target="_blank" rel="noopener">kafka_2.11-1.0.0.tgz</a> (<a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz.asc" target="_blank" rel="noopener">asc</a>, <a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz.sha512" target="_blank" rel="noopener">sha512</a>)</li><li>Scala 2.12  - <a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz" target="_blank" rel="noopener">kafka_2.12-1.0.0.tgz</a> (<a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz.asc" target="_blank" rel="noopener">asc</a>, <a href="https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz.sha512" target="_blank" rel="noopener">sha512</a>)</li></ul></li></ul></blockquote><p>解压Kafka：<code>tar -zxf kafka_2.11-2.3.0.tgz</code></p><h3 id="配置Zookeeper"><a href="#配置Zookeeper" class="headerlink" title="配置Zookeeper"></a>配置Zookeeper</h3><a id="more"></a><ol><li><p>下载<code>Zookeeper</code></p></li><li><p>进入<code>Zookeeper</code>安装目录，编辑配置文件<code>vi conf/zoo.cfg</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=192.168.22.200:2888:3888</span><br><span class="line">server.2=192.168.22.201:2888:3888</span><br><span class="line">server.3=192.168.22.202:2888:3888</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>配置<code>zookeeper</code>集群的<code>myid</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 dataDir 文件夹</span></span><br><span class="line">mkdir /var/lib/zookeeper</span><br><span class="line"><span class="comment"># 在ZK集群机器分别设置对应的myid,如在 192.168.22.200 节点设置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></li><li><p>启动<code>zookeeper</code>集群</p><p>分别在集群中的机器中Kafka安装目录中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>验证启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以观察到如下内容</span></span><br><span class="line"><span class="comment"># 从节点</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/kafka/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 9408.</span><br><span class="line">[root@root bin]<span class="comment"># ./zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/kafka/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line"><span class="comment"># 主节点</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/kafka/apache-zookeeper-3.5.5/bin/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running.</span><br><span class="line">[root@root bin]<span class="comment"># ./zookeeper-3.4.10/bin/zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/kafka/apache-zookeeper-3.5.5/bin/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置Kafka"><a href="#配置Kafka" class="headerlink" title="配置Kafka"></a>配置Kafka</h2><ol><li><p>修改Kafka服务器配置文件</p><p>进入Kafka安装目录，编辑配置文件<code>vi config/service.properties</code>，修改以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改broker.id，每台服务器的broker.id为唯一的integer类型数字</span></span><br><span class="line">broker.id=0</span><br><span class="line"><span class="comment"># 添加主节点监听端口，IP为本机IP地址</span></span><br><span class="line">listeners=PLAINTEXT://192.168.22.200:9092</span><br><span class="line"><span class="comment"># 设置Zookeeper集群连接</span></span><br><span class="line">zookeeper.connect=192.168.22.200:2181,192.168.22.201:2181,192.168.22.202:2181</span><br></pre></td></tr></table></figure></li><li><p>启动Kafka集群</p><p>在每台服务器的Kafka安装目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>使用zkCli进入Zookeeper，在Zookeeper安装目录执行<code>./bin/zkCli.sh -server 192.168.22.200:2181</code>(Zookeeper集群任意一台均可)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到多出来许多节点，这些都是Kafka在ZK上注册的节点</span></span><br><span class="line">[cluster, controller_epoch, controller, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</span><br></pre></td></tr></table></figure><blockquote><p>controller：控制节点</p><p>brokers：Kafka集群的broker信息，以及topic信息</p><p>consumers：ids/owners/offsets</p></blockquote></li><li><p>停止Kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Kafka使用文档：<a href="https://kafka.apache.org/10/documentation.html#quickstart" target="_blank" rel="noopener">https://kafka.apache.org/10/documentation.html#quickstart</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Apache Kafka是一款分布式消息发布和订阅系统，具有高性能、高吞吐量的特点而被广泛应用与大数据传输场景。它由LinkedIn公司开发，使用Scala语言编写，之后成为Apache基金会的一个顶级项目。&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;集群搭建&quot;&gt;&lt;a href=&quot;#集群搭建&quot; class=&quot;headerlink&quot; title=&quot;集群搭建&quot;&gt;&lt;/a&gt;集群搭建&lt;/h2&gt;&lt;h3 id=&quot;下载并解压Kafka包&quot;&gt;&lt;a href=&quot;#下载并解压Kafka包&quot; class=&quot;headerlink&quot; title=&quot;下载并解压Kafka包&quot;&gt;&lt;/a&gt;下载并解压Kafka包&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方下载地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意Kafka所基于的Scala版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary downloads:&lt;ul&gt;
&lt;li&gt;Scala 2.11  - &lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kafka_2.11-1.0.0.tgz&lt;/a&gt; (&lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz.asc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;asc&lt;/a&gt;, &lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.11-1.0.0.tgz.sha512&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sha512&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Scala 2.12  - &lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kafka_2.12-1.0.0.tgz&lt;/a&gt; (&lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz.asc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;asc&lt;/a&gt;, &lt;a href=&quot;https://archive.apache.org/dist/kafka/1.0.0/kafka_2.12-1.0.0.tgz.sha512&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sha512&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;解压Kafka：&lt;code&gt;tar -zxf kafka_2.11-2.3.0.tgz&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置Zookeeper&quot;&gt;&lt;a href=&quot;#配置Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;配置Zookeeper&quot;&gt;&lt;/a&gt;配置Zookeeper&lt;/h3&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat外网远程Debug</title>
    <link href="http://yoursite.com/2019/06/30/devNote/Tomcat%E5%A4%96%E7%BD%91%E8%BF%9C%E7%A8%8BDebug/"/>
    <id>http://yoursite.com/2019/06/30/devNote/Tomcat外网远程Debug/</id>
    <published>2019-06-30T03:07:22.372Z</published>
    <updated>2019-06-30T03:08:14.457Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>保持远端代码版本本地代码版本一致</p></li><li><p>执行<code>sudo vim ${tomcat}/bin/catalina.sh</code>进行编辑，其中<code>${tomcat}</code>为tomcat的安装目录</p></li><li><p>添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span><br></pre></td></tr></table></figure><p>其中address为开发的远程debug的端口号</p></li><li><p>把开放远程debug的端口加到防火墙配置中</p></li><li><p>及时关闭开发的debug端口</p></li><li><p>编辑<code>sudo vim /etc/sysconfig/iptables</code></p></li><li><p>添加如下配置<code>-A INPUT -p tcp -m tcp --dport 5000 -j ACCEPT</code></p></li><li><p><code>:wq</code>保存退出</p></li><li><p>重启防火墙<code>sudo service iptables restart</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;保持远端代码版本本地代码版本一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行&lt;code&gt;sudo vim ${tomcat}/bin/catalina.sh&lt;/code&gt;进行编辑，其中&lt;code&gt;${tomcat}&lt;/code&gt;为tomcat的安装目录&lt;/p&gt;
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat Debug" scheme="http://yoursite.com/tags/Tomcat-Debug/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7.2安装htop</title>
    <link href="http://yoursite.com/2019/06/30/Linux/CentOS7.2%E5%AE%89%E8%A3%85htop/"/>
    <id>http://yoursite.com/2019/06/30/Linux/CentOS7.2安装htop/</id>
    <published>2019-06-30T03:05:02.682Z</published>
    <updated>2019-06-30T03:06:00.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在CentOS7-2中安装htop"><a href="#在CentOS7-2中安装htop" class="headerlink" title="在CentOS7.2中安装htop"></a>在CentOS7.2中安装htop</h2><h3 id="安装gcc及其编译的库"><a href="#安装gcc及其编译的库" class="headerlink" title="安装gcc及其编译的库"></a>安装<code>gcc</code>及其编译的库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果没有安装gcc，按如下来安装</span><br><span class="line">yum install -y gcc</span><br><span class="line"></span><br><span class="line">安装后，编译htop需要安装一个编译Linux内核的库</span><br><span class="line">yum install -y ncurses-devel</span><br></pre></td></tr></table></figure><h3 id="htop下载，编译和安装"><a href="#htop下载，编译和安装" class="headerlink" title="htop下载，编译和安装"></a><code>htop</code>下载，编译和安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">htop下载</span><br><span class="line">wget http://sourceforge.net/projects/htop/files/latest/download</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">tar -zxf download</span><br><span class="line"><span class="built_in">cd</span> htop-1.0.2</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在CentOS7-2中安装htop&quot;&gt;&lt;a href=&quot;#在CentOS7-2中安装htop&quot; class=&quot;headerlink&quot; title=&quot;在CentOS7.2中安装htop&quot;&gt;&lt;/a&gt;在CentOS7.2中安装htop&lt;/h2&gt;&lt;h3 id=&quot;安装gcc
      
    
    </summary>
    
      <category term="CentOS" scheme="http://yoursite.com/categories/CentOS/"/>
    
    
      <category term="htop" scheme="http://yoursite.com/tags/htop/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 18.04配置静态IP地址</title>
    <link href="http://yoursite.com/2019/06/30/Linux/Ubuntu%2018.04%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2019/06/30/Linux/Ubuntu 18.04配置静态IP地址/</id>
    <published>2019-06-30T03:01:09.673Z</published>
    <updated>2019-06-30T03:04:19.234Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>编辑网络配置文件</p><blockquote><p><code>vi /etc/netplan/50-cloud-init.yaml</code></p></blockquote></li><li><p>将原文件修改为如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># This file is generated from information provided by</span><br><span class="line"># the datasource.  Changes to it will not persist across an instance.</span><br><span class="line"># To disable cloud-init&apos;s network configuration capabilities, write a file</span><br><span class="line"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span><br><span class="line"># network: &#123;config: disabled&#125;</span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">        dhcp4: no</span><br><span class="line">        dhcp6: no </span><br><span class="line">        addresses: [192.168.22.100/24]</span><br><span class="line">        optional: true</span><br><span class="line">        gateway4: 192.168.22.2</span><br><span class="line">        nameservers:</span><br><span class="line">                addresses: [8.8.8.8,202.96.209.133]</span><br><span class="line">version: 2</span><br></pre></td></tr></table></figure></li><li><p>启用配置<code>netplan apply</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;编辑网络配置文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vi /etc/netplan/50-cloud-init.yaml&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将原文件修改为如下内容&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
      <category term="Ubuntu" scheme="http://yoursite.com/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 18.04 vi编辑器原格式粘贴</title>
    <link href="http://yoursite.com/2019/06/30/Linux/Ubuntu%2018.04%20vi%E7%BC%96%E8%BE%91%E5%99%A8%E5%8E%9F%E6%A0%BC%E5%BC%8F%E7%B2%98%E8%B4%B4/"/>
    <id>http://yoursite.com/2019/06/30/Linux/Ubuntu 18.04 vi编辑器原格式粘贴/</id>
    <published>2019-06-30T03:00:20.296Z</published>
    <updated>2019-06-30T03:04:02.010Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用vi编辑器打开文件</li><li>使用命令编辑模式(即刚使用vi编辑器打开文件状态)</li><li>输入<code>:set paste</code>，回车后，按<code>i</code>进入编辑模式，即可使用原样粘贴</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用vi编辑器打开文件&lt;/li&gt;
&lt;li&gt;使用命令编辑模式(即刚使用vi编辑器打开文件状态)&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;:set paste&lt;/code&gt;，回车后，按&lt;code&gt;i&lt;/code&gt;进入编辑模式，即可使用原样粘贴&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Ubuntu" scheme="http://yoursite.com/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7设置固定IP</title>
    <link href="http://yoursite.com/2019/06/30/Linux/CentOS7%E5%9B%BA%E5%AE%9AIP/"/>
    <id>http://yoursite.com/2019/06/30/Linux/CentOS7固定IP/</id>
    <published>2019-06-30T02:39:21.645Z</published>
    <updated>2019-06-30T06:02:42.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看当前启用的网卡"><a href="#查看当前启用的网卡" class="headerlink" title="查看当前启用的网卡"></a>查看当前启用的网卡</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@root ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:9c:f1:80 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.22.128/24 brd 192.168.22.255 scope global noprefixroute dynamic ens33</span><br><span class="line">       valid_lft 1453sec preferred_lft 1453sec</span><br><span class="line">    inet6 fe80::d5c8:a782:53b7:4e5b/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@root ~]<span class="comment"># cd /etc/sysconfig/network-scripts</span></span><br><span class="line">[root@root network-scripts]<span class="comment"># ls -ltr ifcfg-*</span></span><br><span class="line">-rw-r--r--. 1 root root 254 1月   3 2018 ifcfg-lo</span><br><span class="line">-rw-r--r--. 1 root root 310 6月  24 16:27 ifcfg-ens33</span><br></pre></td></tr></table></figure><blockquote><p>如上所示，修改<code>ifcfg-ens33</code>设置为静态IP</p></blockquote><a id="more"></a><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为如下内容</span></span><br><span class="line">TYPE=<span class="string">"Ethernet"</span></span><br><span class="line">PROXY_METHOD=<span class="string">"none"</span></span><br><span class="line">BROWSER_ONLY=<span class="string">"no"</span></span><br><span class="line">BOOTPROTO=<span class="string">"static"</span></span><br><span class="line">DEFROUTE=<span class="string">"yes"</span></span><br><span class="line">IPV4_FAILURE_FATAL=<span class="string">"no"</span></span><br><span class="line">IPV6INIT=<span class="string">"yes"</span></span><br><span class="line">IPV6_AUTOCONF=<span class="string">"yes"</span></span><br><span class="line">IPV6_DEFROUTE=<span class="string">"yes"</span></span><br><span class="line">IPV6_FAILURE_FATAL=<span class="string">"no"</span></span><br><span class="line">IPV6_ADDR_GEN_MODE=<span class="string">"stable-privacy"</span></span><br><span class="line">NAME=<span class="string">"ens33"</span></span><br><span class="line">UUID=<span class="string">"213b156a-84f4-413f-9e3d-87216e967165"</span></span><br><span class="line">DEVICE=<span class="string">"ens33"</span></span><br><span class="line">ONBOOT=<span class="string">"yes"</span></span><br><span class="line">IPADDR=192.168.22.200</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.22.2</span><br><span class="line">DNS1=114.114.114.114 //DNS</span><br><span class="line">NM_CONTROLLED=no //是否由networkmanager控制，no否</span><br></pre></td></tr></table></figure><h2 id="保存-重启网络"><a href="#保存-重启网络" class="headerlink" title="保存 重启网络"></a>保存 重启网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看当前启用的网卡&quot;&gt;&lt;a href=&quot;#查看当前启用的网卡&quot; class=&quot;headerlink&quot; title=&quot;查看当前启用的网卡&quot;&gt;&lt;/a&gt;查看当前启用的网卡&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@root ~]&lt;span class=&quot;comment&quot;&gt;# ip addr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    inet 127.0.0.1/8 scope host lo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       valid_lft forever preferred_lft forever&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    inet6 ::1/128 scope host &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       valid_lft forever preferred_lft forever&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    link/ether 00:0c:29:9c:f1:80 brd ff:ff:ff:ff:ff:ff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    inet 192.168.22.128/24 brd 192.168.22.255 scope global noprefixroute dynamic ens33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       valid_lft 1453sec preferred_lft 1453sec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    inet6 fe80::d5c8:a782:53b7:4e5b/64 scope link noprefixroute &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       valid_lft forever preferred_lft forever&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@root ~]&lt;span class=&quot;comment&quot;&gt;# cd /etc/sysconfig/network-scripts&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@root network-scripts]&lt;span class=&quot;comment&quot;&gt;# ls -ltr ifcfg-*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r--r--. 1 root root 254 1月   3 2018 ifcfg-lo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r--r--. 1 root root 310 6月  24 16:27 ifcfg-ens33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如上所示，修改&lt;code&gt;ifcfg-ens33&lt;/code&gt;设置为静态IP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="FTP" scheme="http://yoursite.com/categories/FTP/"/>
    
      <category term="CentOS" scheme="http://yoursite.com/categories/FTP/CentOS/"/>
    
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
</feed>
